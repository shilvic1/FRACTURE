<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Fracture â€” Online Game</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://unpkg.com/peerjs@1.5.2/dist/peerjs.min.js"></script>
    <style>
        :root {
            --accent: #00ffff;
            --bg: #000010;
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%;
            margin: 0;
            font-family: 'Press Start 2P', monospace;
            background: linear-gradient(180deg, var(--bg), #000);
            color: var(--accent);
            overflow: hidden;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            text-align: center;
        }

        .game-status {
            font-size: 14px;
            margin-bottom: 20px;
            padding: 15px;
            border: 2px dashed rgba(0, 255, 255, 0.15);
            border-radius: 8px;
            min-width: 300px;
        }
        
        #gameArea {
            width: 80%;
            height: 400px;
            background: rgba(0, 0, 0, 0.5);
            border: 1px solid var(--accent);
            position: relative;
            margin-bottom: 20px;
            overflow: hidden;
        }
        
        .player {
            position: absolute;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: grid;
            place-items: center;
            font-size: 18px;
            font-weight: 900;
            box-shadow: 0 0 12px rgba(0, 255, 255, 0.8);
            transition: top 0.1s linear, left 0.1s linear; /* Smooth movement */
        }

        #player1 {
            background-color: var(--accent);
            color: #000;
            left: 50px;
            top: 50%;
        }

        #player2 {
            background-color: #ff00ff; /* Different color for opponent */
            color: #000;
            left: calc(100% - 80px);
            top: 50%;
        }
        
        .modal {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.9);
            display: none;
            align-items: center;
            justify-content: center;
            flex-direction: column;
            z-index: 10;
            font-size: 16px;
        }

        .modal.show {
            display: flex;
        }

        .btn {
            padding: 14px 20px;
            font-size: 16px;
            color: #001;
            background-image: linear-gradient(180deg, rgba(0, 255, 255, 0.95), rgba(0, 220, 220, 0.85));
            border-radius: 12px;
            border: none;
            cursor: pointer;
            font-weight: 700;
            margin: 10px;
        }

        .btn.secondary {
            background: transparent;
            border: 2px dashed rgba(0, 255, 255, 0.12);
            color: var(--accent);
            font-weight: 600
        }
    </style>
</head>
<body>
    <h1>Online Fracture</h1>

    <div class="game-status" id="status">
        Connecting...
    </div>

    <div id="gameArea">
        <div class="player" id="player1">1</div>
        <div class="player" id="player2">2</div>
    </div>

    <div id="gameOverModal" class="modal">
        <h2 id="gameOverMessage">GAME OVER</h2>
        <button class="btn" id="restartBtn">Restart Match</button>
        <button class="btn secondary" id="backToMenuBtn">Back to Menu</button>
    </div>

    <script>
        // --- Game Setup ---
        const urlParams = new URLSearchParams(window.location.search);
        const mode = urlParams.get('mode'); // 'quick', 'host', or 'join'
        const roomID = urlParams.get('room'); // The custom room ID
        const roomSize = urlParams.get('size'); // Room size for host

        const statusDisplay = document.getElementById('status');
        const player1El = document.getElementById('player1');
        const player2El = document.getElementById('player2');
        const gameArea = document.getElementById('gameArea');
        const gameOverModal = document.getElementById('gameOverModal');
        const gameOverMessage = document.getElementById('gameOverMessage');
        const restartBtn = document.getElementById('restartBtn');
        const backToMenuBtn = document.getElementById('backToMenuBtn');

        let peer = null;
        let conn = null;
        let isHost = (mode === 'host');
        let myPlayerID = isHost ? 'player1' : 'player2';
        let opponentPlayerID = isHost ? 'player2' : 'player1';
        let gameActive = true;
        
        // Initial state (position is normalized 0-100%)
        let gameState = {
            player1: { x: 10, y: 50, health: 100, isDead: false },
            player2: { x: 90, y: 50, health: 100, isDead: false }
        };

        // --- PeerJS Connection Logic ---

        function initPeer() {
            // Use the roomID as the PeerID for the host, otherwise generate a random ID
            const peerId = isHost ? roomID : `CLIENT-${Math.random().toString(36).substr(2, 9).toUpperCase()}`;
            peer = new Peer(peerId);

            peer.on('open', (id) => {
                console.log('My Peer ID is: ' + id);
                if (isHost) {
                    statusDisplay.textContent = `Hosting room: ${roomID}. Waiting for opponent...`;
                } else if (mode === 'join') {
                    statusDisplay.textContent = `Attempting to join room: ${roomID}...`;
                    connectToHost(roomID);
                } else if (mode === 'quick') {
                    // Quick match logic (e.g., connect to a discovery server, or a hardcoded default host)
                    statusDisplay.textContent = 'Searching for Quick Match... (Simulating connect to ROOM-A1B2C3)';
                    connectToHost('ROOM-A1B2C3'); // Simulation: Assume a fixed host ID for quick match
                }
            });

            peer.on('error', (err) => {
                console.error('PeerJS Error:', err);
                statusDisplay.textContent = `Error: ${err.type}. Check console.`;
            });

            // Host: Listen for incoming connections
            if (isHost) {
                peer.on('connection', (c) => {
                    // Only accept the first connection for a 2-player game
                    if (conn) { c.close(); return; }
                    conn = c;
                    setupConnection(conn);
                    statusDisplay.textContent = 'Opponent connected! Game starting...';
                    // Send initial state to client
                    sendData({ type: 'START_GAME', state: gameState });
                });
            }
        }

        function connectToHost(hostId) {
            conn = peer.connect(hostId);
            setupConnection(conn);
        }

        function setupConnection(c) {
            conn.on('open', () => {
                statusDisplay.textContent = isHost ? 'Connection established with opponent.' : 'Joined host. Waiting for game start...';
                
                // Client must send a READY message to host
                if(!isHost) {
                    sendData({ type: 'READY_TO_START' });
                }
            });

            conn.on('data', receiveData);
            
            conn.on('close', () => {
                statusDisplay.textContent = 'Connection lost. Opponent disconnected.';
                if(gameActive) {
                    gameOverModal.classList.add('show');
                    gameOverMessage.textContent = 'VICTORY! Opponent Disconnected.';
                    gameActive = false;
                }
            });
        }

        // --- Game Logic and Sync ---
        
        function sendData(data) {
            if (conn && conn.open) {
                conn.send(data);
            }
        }

        function receiveData(data) {
            console.log('Received:', data);
            
            if (!gameActive) return;

            switch (data.type) {
                case 'START_GAME':
                case 'STATE_SYNC':
                    // Update the full game state from the opponent
                    gameState = data.state;
                    updateScreen();
                    break;
                case 'MOVE':
                    // Opponent moved, update their position in the state
                    const targetPlayer = (data.player === myPlayerID) ? opponentPlayerID : myPlayerID;
                    gameState[targetPlayer].x = data.x;
                    gameState[targetPlayer].y = data.y;
                    updateScreen();
                    break;
                case 'ABILITY_USE':
                    handleAbility(data.player, data.abilityName);
                    break;
                case 'DAMAGE':
                    // Apply damage to the local player's health
                    gameState[myPlayerID].health -= data.amount;
                    console.log(`${myPlayerID} took ${data.amount} damage. Health: ${gameState[myPlayerID].health}`);
                    
                    if (gameState[myPlayerID].health <= 0) {
                        gameState[myPlayerID].isDead = true;
                        handleGameOver(opponentPlayerID); // Opponent wins
                    }
                    // Immediately send updated state to sync health/death
                    sendData({ type: 'STATE_SYNC', state: gameState });
                    updateScreen();
                    break;
            }
        }

        // Function to render the player elements based on the state
        function updateScreen() {
            // Convert normalized X (0-100) to pixel position for CSS
            player1El.style.left = `${gameState.player1.x}%`;
            player1El.style.top = `${gameState.player1.y}%`;
            player1El.style.opacity = gameState.player1.isDead ? 0.3 : 1;
            player1El.textContent = `P1: ${gameState.player1.health}`;

            player2El.style.left = `${gameState.player2.x}%`;
            player2El.style.top = `${gameState.player2.y}%`;
            player2El.style.opacity = gameState.player2.isDead ? 0.3 : 1;
            player2El.textContent = `P2: ${gameState.player2.health}`;
        }
        
        // --- Game Input (Movement/Abilities) ---

        // Simple movement simulation
        document.addEventListener('keydown', (e) => {
            if (!gameActive || !conn || !conn.open) return;

            let deltaX = 0;
            let deltaY = 0;
            const moveSpeed = 3; // 3% per key press

            switch (e.key) {
                case 'ArrowUp':
                case 'w':
                    deltaY = -moveSpeed;
                    break;
                case 'ArrowDown':
                case 's':
                    deltaY = moveSpeed;
                    break;
                case 'ArrowLeft':
                case 'a':
                    deltaX = -moveSpeed;
                    break;
                case 'ArrowRight':
                case 'd':
                    deltaX = moveSpeed;
                    break;
                case ' ': // Space for Ability
                    useAbility('FracturePulse'); 
                    return; // Don't sync movement, sync ability instead
            }
            
            if (deltaX !== 0 || deltaY !== 0) {
                // Update local state for the player
                gameState[myPlayerID].x = Math.min(100, Math.max(0, gameState[myPlayerID].x + deltaX));
                gameState[myPlayerID].y = Math.min(100, Math.max(0, gameState[myPlayerID].y + deltaY));
                
                // Sync the movement to the opponent
                sendData({
                    type: 'MOVE',
                    player: myPlayerID,
                    x: gameState[myPlayerID].x,
                    y: gameState[myPlayerID].y
                });
                updateScreen();
            }
        });

        // Simulating an ability use (e.g., a projectile or hit)
        function useAbility(abilityName) {
            console.log(`${myPlayerID} used ${abilityName}!`);
            statusDisplay.textContent = `${myPlayerID} used ${abilityName}! (Press R to simulate damage)`;
            
            // Send ability notification to opponent (for visual effects)
            sendData({ type: 'ABILITY_USE', player: myPlayerID, abilityName });
            
            // Simplified damage logic: host always calculates damage for opponent
            // In a real game, this needs security/verification, but for P2P, one side often takes authority.
            if (isHost) {
                // Host sends DAMAGE to P2 (the client)
                sendData({ type: 'DAMAGE', amount: 20 });
            } else {
                // Client sends ABILITY_USE to host, then host should send DAMAGE back to client if successful
                // For simplicity, let's just send the ability and let the host determine the outcome
            }
        }
        
        // Handle ability for visual/logic if opponent uses it
        function handleAbility(player, abilityName) {
            console.log(`${player} used ${abilityName} on their screen.`);
            // Implement visual effects for the opponent's ability here
        }

        // Simulating damage (for testing)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'r' && gameActive) {
                console.log('Simulating damage to opponent...');
                sendData({ type: 'DAMAGE', amount: 15 });
            }
        });


        // --- Game Over Logic ---

        function handleGameOver(winnerID) {
            gameActive = false;
            gameOverModal.classList.add('show');
            
            if (winnerID === myPlayerID) {
                gameOverMessage.textContent = 'VICTORY!';
            } else {
                gameOverMessage.textContent = 'DEFEAT!';
            }
        }

        restartBtn.addEventListener('click', () => {
            // Simple restart: reload the page with current parameters
            window.location.reload();
        });

        backToMenuBtn.addEventListener('click', () => {
            // Go back to the main start menu
            window.location.href = 'index.html';
        });

        // --- Initial Call ---
        initPeer();
        updateScreen();

    </script>
</body>
</html>
