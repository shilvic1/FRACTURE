<!DOCTYPE html>
<html>
    <head>
        <title>Fracture - PvP Arena</title>
        <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>
        <style>
            body {
                margin: 0;
                overflow: hidden;
                background: #111;
                font-family: 'Courier New', Courier, monospace;
            }

            canvas {
                display: block;
            }

            /* UI LAYOUT */
            #uiLayer {
                position: fixed;
                inset: 0;
                pointer-events: none;
                display: flex;
                flex-direction: column;
                justify-content: space-between;
                padding: 20px;
            }

            /* TOP BAR: HEALTH BARS */
            .top-bar {
                display: flex;
                justify-content: space-between;
                align-items: flex-start;
                width: 100%;
            }

            .player-card {
                width: 40%;
                max-width: 400px;
                background: rgba(0, 0, 0, 0.6);
                border: 1px solid #444;
                padding: 5px;
                border-radius: 4px;
                position: relative;
            }

            .hp-bar-bg {
                width: 100%;
                height: 20px;
                background: #333;
                border: 1px solid #000;
                margin-top: 5px;
            }

            .hp-bar-fill {
                height: 100%;
                background: #0f0;
                width: 100%;
                transition: width 0.1s linear, background 0.2s;
            }
            
            .energy-bar-bg {
                width: 100%;
                height: 6px;
                background: #222;
                margin-top: 2px;
            }
            .energy-bar-fill {
                height: 100%;
                background: #0ff;
                width: 100%;
                transition: width 0.1s linear;
            }

            .name-tag {
                color: #fff;
                font-weight: bold;
                font-size: 14px;
                display: flex;
                justify-content: space-between;
            }

            /* P1 (Left) specific */
            #p1Card .hp-bar-fill { background: #00ffaa; }
            /* P2 (Right) specific */
            #p2Card .hp-bar-fill { background: #ff3333; }
            #p2Card { text-align: right; }

            /* CONNECTION OVERLAY */
            #connectionOverlay {
                position: fixed;
                inset: 0;
                background: #050505;
                z-index: 100;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                color: #0ff;
            }
            .loader {
                width: 40px;
                height: 40px;
                border: 4px solid #0ff;
                border-top: 4px solid transparent;
                border-radius: 50%;
                animation: spin 1s linear infinite;
                margin-bottom: 20px;
            }
            @keyframes spin { 100% { transform: rotate(360deg); } }
            
            /* WINNER OVERLAY */
            #winOverlay {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.9);
                border: 2px solid #fff;
                padding: 40px;
                text-align: center;
                color: #fff;
                z-index: 50;
                display: none;
            }
            #winTitle { font-size: 40px; font-weight: bold; margin-bottom: 10px; color: #ff0; }
            #winSub { font-size: 14px; color: #aaa; }
            button.retry-btn {
                margin-top: 20px;
                padding: 10px 20px;
                background: #0ff;
                border: none;
                font-weight: bold;
                cursor: pointer;
                pointer-events: auto;
            }

            /* ABILITY BAR */
            #abilityBar {
                align-self: center;
                display: flex;
                gap: 5px;
                background: rgba(0,0,0,0.5);
                padding: 5px;
                border-radius: 5px;
                border: 1px solid #333;
            }
            .slot {
                width: 40px;
                height: 40px;
                background: #222;
                border: 1px solid #555;
                position: relative;
                display: grid;
                place-items: center;
                color: #fff;
                font-size: 10px;
                font-weight: bold;
                cursor: default; /* Make it look like a button */
            }
            .cd-overlay {
                position: absolute;
                inset: 0;
                background: rgba(0,0,0,0.7);
                clip-path: inset(0 0 0 0);
                transition: clip-path 0.1s linear;
            }
            .energy-cost-text {
                position: absolute;
                bottom: 2px;
                right: 2px;
                font-size: 8px;
                color: #0ff;
                font-weight: normal;
                text-shadow: 0 0 2px #000;
            }
            
            /* NOTIFICATIONS */
            #notifArea {
                position: fixed;
                top: 80px;
                left: 50%;
                transform: translateX(-50%);
                text-align: center;
                color: #fff;
                font-size: 14px;
                text-shadow: 0 2px 4px #000;
                z-index: 20;
            }

        </style>
    </head>
    <body>
        <canvas id="gameCanvas"></canvas>
        
        <div id="uiLayer">
            <div class="top-bar">
                <div class="player-card" id="p1Card">
                    <div class="name-tag">
                        <span>YOU</span>
                        <span id="p1HpText">100/100</span>
                    </div>
                    <div class="hp-bar-bg"><div class="hp-bar-fill" id="p1HpFill"></div></div>
                    <div class="energy-bar-bg"><div class="energy-bar-fill" id="p1EngFill"></div></div>
                </div>

                <div class="player-card" id="p2Card">
                    <div class="name-tag">
                        <span id="p2HpText">100/100</span>
                        <span>OPPONENT</span>
                    </div>
                    <div class="hp-bar-bg"><div class="hp-bar-fill" id="p2HpFill"></div></div>
                </div>
            </div>

            <div id="abilityBar">
                <div class="slot">Q<div class="cd-overlay" id="cdQ"></div><span class="energy-cost-text">50 E</span></div>
                <div class="slot">1<div class="cd-overlay" id="cd1"></div><span class="energy-cost-text">80 E</span></div>
                <div class="slot">2<div class="cd-overlay" id="cd2"></div><span class="energy-cost-text">100 E</span></div>
                <div class="slot">3<div class="cd-overlay" id="cd3"></div><span class="energy-cost-text">50 E</span></div>
                <div class="slot">F</div>
            </div>
        </div>

        <div id="connectionOverlay">
            <div class="loader"></div>
            <h2 id="connStatus">CONNECTING...</h2>
            <div id="connDetails" style="color:#666; margin-top:10px; font-size:12px;">Initializing PeerJS...</div>
        </div>

        <div id="winOverlay">
            <div id="winTitle">VICTORY</div>
            <div id="winSub">You defeated your opponent!</div>
            <button class="retry-btn" onclick="location.reload()">Return to Lobby</button>
        </div>
        
        <div id="notifArea"></div>

        <script>
            // ================= CONFIG & SETUP =================
            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // URL Params for PeerJS
            const urlParams = new URLSearchParams(window.location.search);
            const mode = urlParams.get('mode'); // 'host', 'join'
            const roomId = urlParams.get('room');
            
            // Game State
            let gameActive = false;
            let isHost = (mode === 'host' || mode === 'quick');
            let peer = null;
            let conn = null;

            // Physics Constants
            const GRAVITY = 0.8;
            const GROUND_Y = canvas.height - 100;

            // ================= PLAYER OBJECTS =================
            // Local Player
            const player = {
                x: 200, y: GROUND_Y - 60, w: 40, h: 60,
                vx: 0, vy: 0,
                hp: 100, maxHp: 100, energy: 100, maxEnergy: 100,
                facing: 1, // 1 = right, -1 = left
                color: "#00ffaa",
                isBlocking: false,
                isDashing: false,
                isAttacking: false,
                invincible: false,
                attackCooldown: 0,
                dashCooldown: 0, // NEW
                smashCooldown: 0, // NEW
                ability2Cooldown: 0, // NEW
                ability3Cooldown: 0, // NEW
                stats: { str: 10, spd: 5, def: 0 },
                build: localStorage.getItem('fracture_charbuild') || 'Strength'
            };

            // Remote Player (Opponent)
            const opponent = {
                x: 800, y: GROUND_Y - 60, w: 40, h: 60,
                hp: 100, maxHp: 100,
                facing: -1,
                color: "#ff3333",
                isBlocking: false,
                isAttacking: false, // Visual only
                connected: false
            };

            // Build Stats Configuration
            const builds = {
                'Strength': { str: 15, spd: 4, hp: 120, energyRegen: 0.5, color: '#ff8800' }, // Added energyRegen
                'Speed': 	{ str: 8, spd: 9, hp: 90, energyRegen: 1.0, color: '#00ffff' },
                'Defense': 	{ str: 10, spd: 3, hp: 150, energyRegen: 0.2, color: '#4444ff' },
                'Energy': 	{ str: 12, spd: 5, hp: 100, energyRegen: 1.5, color: '#aa00ff' }
            };
            
            // Apply Build
            if(builds[player.build]) {
                const b = builds[player.build];
                player.stats.str = b.str;
                player.stats.spd = b.spd;
                player.maxHp = b.hp;
                player.hp = b.hp;
                player.color = b.color;
                player.energyRegen = b.energyRegen || 0.5; // NEW: Energy Regen rate
            }
            opponent.hp = 100; // Will sync later

            // Inputs
            const keys = {};
            document.addEventListener('keydown', e => {
                keys[e.key.toLowerCase()] = true;
                // NEW: Ability checks on keydown
                if (gameActive) {
                    if (e.key.toLowerCase() === 'q') performDash();
                    if (e.key === '1') performSmash();
                    // if (e.key === '2') performAbility2();
                    // if (e.key === '3') performAbility3();
                }
            });
            document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
            let mouseDown = false;
            document.addEventListener('mousedown', () => mouseDown = true);
            document.addEventListener('mouseup', () => mouseDown = false);

            // VFX Arrays
            const particles = [];
            const damageNums = [];
            let screenShake = 0;

            // ================= NETWORKING (PEERJS) - UNMODIFIED =================
            // [ ... initNetwork(), handleConnection(c), sendData(payload), processData(data) functions remain unchanged ... ]
            function initNetwork() {
                const statusEl = document.getElementById('connStatus');
                const detailsEl = document.getElementById('connDetails');

                if (!roomId && mode !== 'quick') {
                    statusEl.innerText = "NO ROOM ID";
                    detailsEl.innerText = "Please use the menu to create a match.";
                    return;
                }

                // Create Peer
                if (isHost) {
                    // We are hosting, we use the roomId passed or generate one
                    peer = new Peer(roomId); 
                    detailsEl.innerText = "Hosting Room: " + roomId;
                } else {
                    // We are joining, random ID is fine for us
                    peer = new Peer(); 
                    detailsEl.innerText = "Connecting to Host...";
                }

                peer.on('open', (id) => {
                    if (isHost) {
                        statusEl.innerText = "WAITING FOR OPPONENT...";
                        peer.on('connection', (c) => {
                            handleConnection(c);
                        });
                    } else {
                        // Connect to Host
                        const c = peer.connect(roomId);
                        handleConnection(c);
                    }
                });

                peer.on('error', (err) => {
                    statusEl.innerText = "CONNECTION ERROR";
                    detailsEl.innerText = err.type;
                });
            }

            function handleConnection(c) {
                conn = c;
                
                conn.on('open', () => {
                    document.getElementById('connectionOverlay').style.display = 'none';
                    gameActive = true;
                    opponent.connected = true;
                    
                    // Send initial handshake (My Max HP / Build info)
                    sendData({ type: 'handshake', maxHp: player.maxHp, x: player.x });
                    
                    showNotif("FIGHT STARTED!");
                });

                conn.on('data', (data) => {
                    processData(data);
                });
                
                conn.on('close', () => {
                    showNotif("OPPONENT DISCONNECTED");
                    opponent.connected = false;
                });
            }

            function sendData(payload) {
                if (conn && conn.open) {
                    conn.send(payload);
                }
            }

            function processData(data) {
                if (data.type === 'sync') {
                    // Position Sync
                    // Simple interpolation could go here, for now direct mapping
                    opponent.x = data.x;
                    opponent.y = data.y;
                    opponent.facing = data.f;
                    opponent.isBlocking = data.blk;
                    opponent.isAttacking = data.atk; // Just for visual flashing
                } 
                else if (data.type === 'handshake') {
                    opponent.maxHp = data.maxHp;
                    opponent.hp = data.maxHp;
                    // Adjust spawn positions: Host left, Client right
                    if (isHost) { player.x = 200; opponent.x = canvas.width - 200; }
                    else { player.x = canvas.width - 200; opponent.x = 200; }
                }
                else if (data.type === 'hit') {
                    // We got hit! "Trust the attacker" logic
                    receiveDamage(data.dmg, data.kbDir, data.kbForce);
                }
                else if (data.type === 'hp_update') {
                    // Just UI sync to be safe
                    opponent.hp = data.hp;
                }
            }

            // ================= GAME LOGIC =================
            function update() {
                if (!gameActive) return;

                // 1. Cooldowns and Energy
                if (player.attackCooldown > 0) player.attackCooldown--;
                if (player.dashCooldown > 0) player.dashCooldown--; // NEW
                if (player.smashCooldown > 0) player.smashCooldown--; // NEW
                // if (player.ability2Cooldown > 0) player.ability2Cooldown--; // NEW
                // if (player.ability3Cooldown > 0) player.ability3Cooldown--; // NEW
                
                // Energy Regeneration
                if (!player.isBlocking) {
                    player.energy += player.energyRegen; // Use build specific regen rate
                    player.energy = Math.min(player.energy, player.maxEnergy);
                }

                // 2. Movement
                let speed = player.stats.spd;
                if (keys['shift']) speed *= 1.5; // Sprint
                if (player.isBlocking) speed *= 0.4;
                if (player.isDashing) speed *= 0; // Prevent movement during dash

                if (!player.isDashing) {
                    if (keys['a']) { player.vx = -speed; player.facing = -1; }
                    else if (keys['d']) { player.vx = speed; player.facing = 1; }
                    else { player.vx *= 0.8; } // Friction
                }
                

                // Jump
                if (keys[' '] && player.y + player.h >= GROUND_Y && !player.isDashing) {
                    player.vy = -15;
                    spawnParticle(player.x + 20, player.y + 60, "#fff", 5);
                }

                // Physics
                player.vy += GRAVITY;
                player.x += player.vx;
                player.y += player.vy;

                // Floor Collision
                if (player.y + player.h > GROUND_Y) {
                    player.y = GROUND_Y - player.h;
                    player.vy = 0;
                }
                // Wall Collision
                if (player.x < 0) player.x = 0;
                if (player.x > canvas.width - player.w) player.x = canvas.width - player.w;

                // 3. Combat Actions
                
                // Blocking
                player.isBlocking = keys['f'] && !player.isAttacking && !player.isDashing;

                // Attacking (LMB)
                if (mouseDown && player.attackCooldown <= 0 && !player.isBlocking && !player.isDashing) {
                    performAttack();
                }

                // 4. Network Sync (Send my state every frame or every other frame)
                sendData({
                    type: 'sync',
                    x: Math.round(player.x),
                    y: Math.round(player.y),
                    f: player.facing,
                    blk: player.isBlocking,
                    atk: player.isAttacking
                });

                // 5. Update VFX
                updateVFX();
            }

            // ================= ABILITY IMPLEMENTATION (NEW) =================
            const ABILITY_CONFIG = {
                'Q': { cost: 50, cd: 60 },
                '1': { cost: 80, cd: 120 }
            }

            function performDash() {
                const config = ABILITY_CONFIG.Q;
                if (player.dashCooldown > 0 || player.energy < config.cost || player.isAttacking) {
                    if (player.energy < config.cost) showNotif("NOT ENOUGH ENERGY");
                    return;
                }

                player.energy -= config.cost;
                player.dashCooldown = config.cd;
                player.isDashing = true;
                player.invincible = true; // Temporary Invincibility

                // Dash Movement
                player.vx = player.facing * 30;
                player.vy = 0;

                // Trail Effect
                const trailInterval = setInterval(() => {
                    spawnParticle(player.x + 20, player.y + 30, player.color, 3);
                }, 20);

                setTimeout(() => {
                    clearInterval(trailInterval);
                    player.isDashing = false;
                    player.invincible = false;
                    player.vx *= 0.5; // Apply a bit of friction at the end
                }, 200); // Dash duration
            }

            function performSmash() {
                const config = ABILITY_CONFIG['1'];
                if (player.smashCooldown > 0 || player.energy < config.cost || player.isAttacking) {
                    if (player.energy < config.cost) showNotif("NOT ENOUGH ENERGY");
                    return;
                }
                
                player.energy -= config.cost;
                player.smashCooldown = config.cd;
                player.isAttacking = true; // Use existing attack state

                // Smash properties
                const range = 80;
                const hitX = player.facing === 1 ? player.x + player.w : player.x - range;
                const hitbox = { x: hitX, y: player.y, w: range, h: player.h };
                const oppBox = { x: opponent.x, y: opponent.y, w: opponent.w, h: opponent.h };
                
                // Visual jump/slam preparation
                player.vy = -5; 
                player.vx = 0;

                // Delay the actual hit to feel like a windup
                setTimeout(() => {
                    if (checkCollision(hitbox, oppBox)) {
                        // HIT! Massive Damage/Knockback
                        const dmg = player.stats.str * 4; 
                        const kbForce = 25;
                        
                        screenShake = 20; // Bigger shake
                        spawnParticle(oppBox.x + 20, oppBox.y + 30, "#ff8800", 25);
                        
                        sendData({
                            type: 'hit',
                            dmg: dmg,
                            kbDir: player.facing,
                            kbForce: kbForce
                        });
                        spawnFloatText("SMASH!", oppBox.x + 20, oppBox.y - 40, "#ff8800");
                    }
                    player.isAttacking = false;
                }, 300);

                setTimeout(() => player.isAttacking = false, 500); // Ensure attack state resets
            }

            // ================= CORE COMBAT =================

            function performAttack() {
                player.isAttacking = true;
                player.attackCooldown = 20;
                
                // Visual Lunge
                player.vx = player.facing * 5; 

                // Hitbox Calculation
                const range = 50 + (player.stats.str * 1.5);
                const hitX = player.facing === 1 ? player.x + player.w : player.x - range;
                const hitbox = { x: hitX, y: player.y, w: range, h: player.h };
                const oppBox = { x: opponent.x, y: opponent.y, w: opponent.w, h: opponent.h };

                // Collision Check
                if (checkCollision(hitbox, oppBox)) {
                    // HIT!
                    const dmg = player.stats.str * 1.5; // Base Damage
                    const kbForce = 10;
                    
                    // Visuals
                    screenShake = 5;
                    spawnParticle(oppBox.x + 20, oppBox.y + 30, "#ff0000", 10);
                    
                    // Network: Tell them they got hit
                    sendData({
                        type: 'hit',
                        dmg: dmg,
                        kbDir: player.facing,
                        kbForce: kbForce
                    });
                }

                setTimeout(() => player.isAttacking = false, 200);
            }

            function receiveDamage(amount, dir, force) {
                if (player.invincible) return;

                let finalDmg = amount;
                
                // Block Check
                if (player.isBlocking) {
                    // Reduce damage
                    finalDmg *= 0.2; 
                    spawnFloatText("BLOCKED", player.x, player.y - 20, "#aaa");
                    screenShake = 2; // Minor shake on block
                } else {
                    spawnFloatText("-" + Math.round(finalDmg), player.x, player.y - 20, "#f00");
                    screenShake = 10;
                    // Blood particles
                    spawnParticle(player.x + 20, player.y + 30, player.color, 15);
                }

                player.hp -= finalDmg;
                player.vx = dir * force * (player.isBlocking ? 0.3 : 1.0); // Less knockback when blocking
                player.vy = -force * 0.5; // Upward knockback
                
                // Send new HP back to sync UI
                sendData({ type: 'hp_update', hp: player.hp });

                checkDeath();
            }

            function checkCollision(r1, r2) {
                return (r1.x < r2.x + r2.w &&
                        r1.x + r1.w > r2.x &&
                        r1.y < r2.y + r2.h &&
                        r1.y + r1.h > r2.y);
            }

            function checkDeath() {
                if (player.hp <= 0) {
                    player.hp = 0;
                    gameActive = false;
                    // Local Loss
                    showWinScreen(false);
                    // Opponent Win logic handled by them seeing your HP hit 0 or just UI
                }
            }

            // ================= VISUALS & DRAWING =================
            function updateVFX() {
                // Particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    let p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.5; // Apply gravity to particles
                    p.life--;
                    if (p.life <= 0) particles.splice(i, 1);
                }
                // Text
                for (let i = damageNums.length - 1; i >= 0; i--) {
                    damageNums[i].y -= 1;
                    damageNums[i].life--;
                    if (damageNums[i].life <= 0) damageNums.splice(i, 1);
                }
                // Shake
                if (screenShake > 0) screenShake--;

                // UI Bars
                const p1HpPct = Math.max(0, (player.hp / player.maxHp) * 100);
                document.getElementById('p1HpFill').style.width = p1HpPct + "%";
                document.getElementById('p1HpText').innerText = Math.ceil(player.hp);
                
                const p1EngPct = Math.max(0, (player.energy / player.maxEnergy) * 100);
                document.getElementById('p1EngFill').style.width = p1EngPct + "%";
                
                const p2Pct = Math.max(0, (opponent.hp / opponent.maxHp) * 100);
                document.getElementById('p2HpFill').style.width = p2Pct + "%";
                document.getElementById('p2HpText').innerText = Math.ceil(opponent.hp);
                
                // Ability Cooldown UI
                updateCooldownUI('cdQ', player.dashCooldown, ABILITY_CONFIG.Q.cd);
                updateCooldownUI('cd1', player.smashCooldown, ABILITY_CONFIG['1'].cd);
                // updateCooldownUI('cd2', player.ability2Cooldown, 100);
                // updateCooldownUI('cd3', player.ability3Cooldown, 80);

                // Check Win via UI sync (backup check)
                if (opponent.hp <= 0 && gameActive) {
                    gameActive = false;
                    showWinScreen(true);
                }
            }
            
            // NEW: Function to manage the cooldown overlay
            function updateCooldownUI(id, currentCD, maxCD) {
                const el = document.getElementById(id);
                if (el) {
                    const percentage = currentCD / maxCD;
                    // Clip-path inset to simulate vertical fill of cooldown
                    const clipValue = percentage * 100; // 0 to 100
                    el.style.clipPath = `inset(${clipValue}% 0 0 0)`;
                }
            }

            function draw() {
                // Shake Offset
                const sx = (Math.random() - 0.5) * screenShake;
                const sy = (Math.random() - 0.5) * screenShake;
                
                ctx.save();
                ctx.translate(sx, sy);
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Background
                const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
                g.addColorStop(0, '#111');
                g.addColorStop(1, '#222');
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Ground
                ctx.fillStyle = "#333";
                ctx.fillRect(0, GROUND_Y, canvas.width, 100);
                ctx.fillStyle = "#444"; // Grid line
                ctx.fillRect(0, GROUND_Y, canvas.width, 4);

                // Draw Opponent
                if (opponent.connected) {
                    ctx.fillStyle = opponent.isBlocking ? "#555" : opponent.color;
                    if (opponent.isAttacking) ctx.fillStyle = "#fff"; // Flash on attack
                    
                    // Simple Rect for now
                    ctx.fillRect(opponent.x, opponent.y, opponent.w, opponent.h);
                    
                    // Direction indicator (Eye)
                    ctx.fillStyle = "#000";
                    if(opponent.facing === 1) ctx.fillRect(opponent.x + 25, opponent.y + 10, 5, 5);
                    else ctx.fillRect(opponent.x + 10, opponent.y + 10, 5, 5);
                }

                // Draw Player
                ctx.fillStyle = player.isBlocking ? "#888" : player.color;
                if (player.isAttacking || player.isDashing) ctx.fillStyle = "#fff"; // Flash for attacks/dash
                ctx.fillRect(player.x, player.y, player.w, player.h);
                
                // Eye
                ctx.fillStyle = "#000";
                if(player.facing === 1) ctx.fillRect(player.x + 25, player.y + 10, 5, 5);
                else ctx.fillRect(player.x + 10, player.y + 10, 5, 5);

                // Particles
                for (let p of particles) {
                    ctx.fillStyle = p.c;
                    ctx.fillRect(p.x, p.y, p.s, p.s);
                }

                // Damage Numbers
                ctx.font = "bold 20px Arial";
                for (let t of damageNums) {
                    ctx.fillStyle = "black";
                    ctx.fillText(t.text, t.x + 2, t.y + 2);
                    ctx.fillStyle = t.c;
                    ctx.fillText(t.text, t.x, t.y);
                }

                ctx.restore();
                requestAnimationFrame(draw);
            }

            function spawnParticle(x, y, color, count) {
                for (let i = 0; i < count; i++) {
                    particles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 20 + Math.random() * 10,
                        c: color,
                        s: Math.random() * 4 + 2
                    });
                }
            }

            function spawnFloatText(text, x, y, color) {
                damageNums.push({ text: text, x: x, y: y, c: color, life: 40 });
            }

            function showNotif(msg) {
                const el = document.getElementById('notifArea');
                el.innerText = msg;
                el.style.opacity = 1;
                setTimeout(() => el.style.opacity = 0, 3000);
            }

            function showWinScreen(isWin) {
                const overlay = document.getElementById('winOverlay');
                const title = document.getElementById('winTitle');
                const sub = document.getElementById('winSub');
                
                overlay.style.display = 'block';
                if (isWin) {
                    title.innerText = "VICTORY";
                    title.style.color = "#0f0";
                    sub.innerText = "You defeated the opponent!";
                } else {
                    title.innerText = "DEFEAT";
                    title.style.color = "#f00";
                    sub.innerText = "You were Fractured.";
                }
            }

            // ================= LOOP START =================
            initNetwork();
            
            setInterval(update, 1000 / 60); // 60 FPS Logic
            draw(); // Render Loop

        </script>
    </body>
</html>
