<!DOCTYPE html>
<html>
    <head>
        <title>Fracture - PvP Arena</title>
        <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>
        <style>
            body {
                margin: 0;
                overflow: hidden;
                background: #111;
                font-family: 'Courier New', Courier, monospace;
            }

            canvas {
                display: block;
            }

            /* UI LAYOUT */
            #uiLayer {
                position: fixed;
                inset: 0;
                pointer-events: none;
                display: flex;
                flex-direction: column;
                justify-content: space-between;
                padding: 20px;
            }

            /* TOP BAR: HEALTH BARS */
            .top-bar {
                display: flex;
                justify-content: space-between;
                align-items: flex-start;
                width: 100%;
            }

            .player-card {
                width: 40%;
                max-width: 400px;
                background: rgba(0, 0, 0, 0.6);
                border: 1px solid #444;
                padding: 5px;
                border-radius: 4px;
                position: relative;
            }

            .hp-bar-bg {
                width: 100%;
                height: 20px;
                background: #333;
                border: 1px solid #000;
                margin-top: 5px;
            }

            .hp-bar-fill {
                height: 100%;
                background: #0f0;
                width: 100%;
                transition: width 0.1s linear, background 0.2s;
            }
            
            .energy-bar-bg {
                width: 100%;
                height: 6px;
                background: #222;
                margin-top: 2px;
            }
            .energy-bar-fill {
                height: 100%;
                background: #0ff;
                width: 100%;
                transition: width 0.1s linear;
            }

            .name-tag {
                color: #fff;
                font-weight: bold;
                font-size: 14px;
                display: flex;
                justify-content: space-between;
            }

            /* P1 (Left) specific */
            #p1Card .hp-bar-fill { background: #00ffaa; }
            /* P2 (Right) specific */
            #p2Card .hp-bar-fill { background: #ff3333; }
            #p2Card { text-align: right; }

            /* CONNECTION OVERLAY */
            #connectionOverlay {
                position: fixed;
                inset: 0;
                background: #050505;
                z-index: 100;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                color: #0ff;
            }
            .loader {
                width: 40px;
                height: 40px;
                border: 4px solid #0ff;
                border-top: 4px solid transparent;
                border-radius: 50%;
                animation: spin 1s linear infinite;
                margin-bottom: 20px;
            }
            @keyframes spin { 100% { transform: rotate(360deg); } }
            
            /* WINNER OVERLAY */
            #winOverlay {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.9);
                border: 2px solid #fff;
                padding: 40px;
                text-align: center;
                color: #fff;
                z-index: 50;
                display: none;
            }
            #winTitle { font-size: 40px; font-weight: bold; margin-bottom: 10px; color: #ff0; }
            #winSub { font-size: 14px; color: #aaa; }
            button.retry-btn {
                margin-top: 20px;
                padding: 10px 20px;
                background: #0ff;
                border: none;
                font-weight: bold;
                cursor: pointer;
                pointer-events: auto;
            }

            /* ABILITY BAR */
            #abilityBar {
                align-self: center;
                display: flex;
                gap: 5px;
                background: rgba(0,0,0,0.5);
                padding: 5px;
                border-radius: 5px;
                border: 1px solid #333;
            }
            .slot {
                width: 40px;
                height: 40px;
                background: #222;
                border: 1px solid #555;
                position: relative;
                display: grid;
                place-items: center;
                color: #fff;
                font-size: 10px;
            }
            .cd-overlay {
                position: absolute;
                inset: 0;
                background: rgba(0,0,0,0.7);
                clip-path: inset(0 0 0 0);
            }
            
            /* NOTIFICATIONS */
            #notifArea {
                position: fixed;
                top: 80px;
                left: 50%;
                transform: translateX(-50%);
                text-align: center;
                color: #fff;
                font-size: 14px;
                text-shadow: 0 2px 4px #000;
                z-index: 20;
            }

        </style>
    </head>
    <body>
        <canvas id="gameCanvas"></canvas>
        
        <div id="uiLayer">
            <div class="top-bar">
                <div class="player-card" id="p1Card">
                    <div class="name-tag">
                        <span>YOU</span>
                        <span id="p1HpText">100/100</span>
                    </div>
                    <div class="hp-bar-bg"><div class="hp-bar-fill" id="p1HpFill"></div></div>
                    <div class="energy-bar-bg"><div class="energy-bar-fill" id="p1EngFill"></div></div>
                </div>

                <div class="player-card" id="p2Card">
                    <div class="name-tag">
                        <span id="p2HpText">100/100</span>
                        <span>OPPONENT</span>
                    </div>
                    <div class="hp-bar-bg"><div class="hp-bar-fill" id="p2HpFill"></div></div>
                </div>
            </div>

            <div id="abilityBar">
                <div class="slot">Q<div class="cd-overlay" id="cdQ"></div></div>
                <div class="slot">1<div class="cd-overlay" id="cd1"></div></div>
                <div class="slot">2<div class="cd-overlay" id="cd2"></div></div>
                <div class="slot">3<div class="cd-overlay" id="cd3"></div></div>
                <div class="slot">F</div>
            </div>
        </div>

        <div id="connectionOverlay">
            <div class="loader"></div>
            <h2 id="connStatus">CONNECTING...</h2>
            <div id="connDetails" style="color:#666; margin-top:10px; font-size:12px;">Initializing PeerJS...</div>
        </div>

        <div id="winOverlay">
            <div id="winTitle">VICTORY</div>
            <div id="winSub">You defeated your opponent!</div>
            <button class="retry-btn" onclick="location.reload()">Return to Lobby</button>
        </div>
        
        <div id="notifArea"></div>

        <script>
            // ================= CONFIG & SETUP =================
            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");
            function fitCanvas() {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            }
            window.addEventListener('resize', fitCanvas);
            fitCanvas();

            // URL Params for PeerJS
            const urlParams = new URLSearchParams(window.location.search);
            const mode = urlParams.get('mode'); // 'host', 'join', 'quick'
            const roomId = urlParams.get('room');
            
            // Game State
            let gameActive = false;
            let isHost = (mode === 'host' || mode === 'quick');
            let peer = null;
            let conn = null;

            // Physics Constants
            const GRAVITY = 0.8;
            const GROUND_Y = canvas.height - 100;

            // ================= PLAYER OBJECTS =================
            // Local Player
            const player = {
                x: 200, y: GROUND_Y - 60, w: 40, h: 60,
                vx: 0, vy: 0,
                hp: 100, maxHp: 100, energy: 100,
                facing: 1, // 1 = right, -1 = left
                color: "#00ffaa",
                isBlocking: false,
                isDashing: false,
                isAttacking: false,
                invincible: false,
                attackCooldown: 0,
                stats: { str: 10, spd: 5, def: 0 },
                build: localStorage.getItem('fracture_charbuild') || 'Strength'
            };

            // Remote Player (Opponent)
            const opponent = {
                x: 800, y: GROUND_Y - 60, w: 40, h: 60,
                hp: 100, maxHp: 100,
                facing: -1,
                color: "#ff3333",
                isBlocking: false,
                isAttacking: false, // Visual only
                connected: false
            };

            // Build Stats Configuration
            const builds = {
                'Strength': { str: 15, spd: 4, hp: 120, color: '#ff8800' },
                'Speed':    { str: 8, spd: 9, hp: 90, color: '#00ffff' },
                'Defense':  { str: 10, spd: 3, hp: 150, color: '#4444ff' },
                'Energy':   { str: 12, spd: 5, hp: 100, color: '#aa00ff' }
            };
            
            // Apply Build
            if(builds[player.build]) {
                const b = builds[player.build];
                player.stats.str = b.str;
                player.stats.spd = b.spd;
                player.maxHp = b.hp;
                player.hp = b.hp;
                player.color = b.color;
            }
            opponent.hp = 100; // Will sync later

            // Inputs
            const keys = {};
            document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
            document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
            let mouseDown = false;
            document.addEventListener('mousedown', () => mouseDown = true);
            document.addEventListener('mouseup', () => mouseDown = false);

            // VFX & Combat arrays (merged from uploaded file)
            const particles = [];       // generic particle objects {x,y,vx,vy,life,c,s}
            const damageNums = [];      // floating damage text {text,x,y,life,c}
            const afterimages = [];     // dash/afterimage effects
            const vfxQueue = [];        // complex VFX events (shockwave, impactRing, fullFlash, projectileTrail)
            let screenShake = 0;
            let screenShakeIntensity = 0;

            // Combat metrics (optional, from uploaded)
            const combatMetrics = {
                totalDamage: 0,
                damageLog: [],
                comboCount: 0,
                comboTimer: 0,
                maxCombo: 0,
                dps: 0
            };
            const COMBO_RESET_TIME = 90;

            // ================= NETWORKING (PEERJS) =================
            function initNetwork() {
                const statusEl = document.getElementById('connStatus');
                const detailsEl = document.getElementById('connDetails');

                if (!roomId && mode !== 'quick') {
                    statusEl.innerText = "NO ROOM ID";
                    detailsEl.innerText = "Please use the menu to create a match.";
                    return;
                }

                // Create Peer
                if (isHost) {
                    // We are hosting, we use the roomId passed or generate one
                    peer = new Peer(roomId); 
                    detailsEl.innerText = "Hosting Room: " + (roomId || '<generated>');
                } else {
                    // We are joining, random ID is fine for us
                    peer = new Peer(); 
                    detailsEl.innerText = "Connecting to Host...";
                }

                peer.on('open', (id) => {
                    if (isHost) {
                        statusEl.innerText = "WAITING FOR OPPONENT...";
                        peer.on('connection', (c) => {
                            handleConnection(c);
                        });
                    } else {
                        // Connect to Host
                        const c = peer.connect(roomId);
                        handleConnection(c);
                    }
                });

                peer.on('error', (err) => {
                    statusEl.innerText = "CONNECTION ERROR";
                    detailsEl.innerText = err.type || err;
                });
            }

            function handleConnection(c) {
                conn = c;
                
                conn.on('open', () => {
                    document.getElementById('connectionOverlay').style.display = 'none';
                    gameActive = true;
                    opponent.connected = true;
                    
                    // Send initial handshake (My Max HP / Build info)
                    sendData({ type: 'handshake', maxHp: player.maxHp, x: player.x, build: player.build });
                    
                    showNotif("FIGHT STARTED!");
                });

                conn.on('data', (data) => {
                    processData(data);
                });
                
                conn.on('close', () => {
                    showNotif("OPPONENT DISCONNECTED");
                    opponent.connected = false;
                });
            }

            function sendData(payload) {
                if (conn && conn.open) {
                    try { conn.send(payload); } catch(e) {}
                }
            }

            function processData(data) {
                if (data.type === 'sync') {
                    // Position Sync
                    opponent.x = data.x;
                    opponent.y = data.y;
                    opponent.facing = data.f;
                    opponent.isBlocking = data.blk;
                    opponent.isAttacking = data.atk; // Just for visual flashing
                } 
                else if (data.type === 'handshake') {
                    opponent.maxHp = data.maxHp;
                    opponent.hp = data.maxHp;
                    // Adjust spawn positions: Host left, Client right
                    if (isHost) { player.x = 200; opponent.x = canvas.width - 200; }
                    else { player.x = canvas.width - 200; opponent.x = 200; }
                }
                else if (data.type === 'hit') {
                    // We got hit! apply damage locally
                    receiveDamage(data.dmg, data.kbDir, data.kbForce);
                }
                else if (data.type === 'hp_update') {
                    // Just UI sync
                    opponent.hp = data.hp;
                }
            }

            // ================= GAME LOGIC =================
            function update() {
                if (!gameActive) return;

                // Movement (simple)
                let speed = player.stats.spd || 5;
                if (keys['a']) { player.vx = -speed; player.facing = -1; }
                else if (keys['d']) { player.vx = speed; player.facing = 1; }
                else { player.vx *= 0.8; } // Friction

                // Jump
                if (keys[' '] && player.y + player.h >= GROUND_Y) {
                    player.vy = -15;
                    spawnParticle(player.x + 20, player.y + 60, "#fff", 5);
                    keys[' '] = false;
                }

                // Physics
                player.vy += GRAVITY;
                player.x += player.vx;
                player.y += player.vy;

                // Floor Collision
                if (player.y + player.h > GROUND_Y) {
                    player.y = GROUND_Y - player.h;
                    player.vy = 0;
                }
                // Wall Collision
                if (player.x < 0) player.x = 0;
                if (player.x > canvas.width - player.w) player.x = canvas.width - player.w;

                // Combat cooldowns
                if (player.attackCooldown > 0) player.attackCooldown--;

                // Blocking
                player.isBlocking = keys['f'];

                // Attacking (LMB)
                if (mouseDown && player.attackCooldown <= 0 && !player.isBlocking) {
                    performAttack();
                }

                // Network Sync
                sendData({
                    type: 'sync',
                    x: Math.round(player.x),
                    y: Math.round(player.y),
                    f: player.facing,
                    blk: player.isBlocking,
                    atk: player.isAttacking
                });

                // Update VFX (merged)
                updateVFX();
            }

            function performAttack() {
                player.isAttacking = true;
                player.attackCooldown = 20;
                
                // Visual Lunge
                player.vx = player.facing * 5; 

                // Hitbox Calculation
                const range = 50 + (player.stats.str * 1.5);
                const hitX = player.facing === 1 ? player.x + player.w : player.x - range;
                const hitbox = { x: hitX, y: player.y, w: range, h: player.h };
                const oppBox = { x: opponent.x, y: opponent.y, w: opponent.w, h: opponent.h };

                // Collision Check
                if (checkCollision(hitbox, oppBox)) {
                    // HIT!
                    const dmg = player.stats.str * 1.5 || 15; // Base Damage
                    const kbForce = 10;
                    
                    // Visuals
                    screenShake = 5;
                    screenShakeIntensity = 6;
                    spawnParticle(oppBox.x + 20, oppBox.y + 30, "#ff0000", 10);
                    
                    // Network: Tell them they got hit
                    sendData({
                        type: 'hit',
                        dmg: dmg,
                        kbDir: player.facing,
                        kbForce: kbForce
                    });

                    // Local VFX push for immediate feedback
                    directionalBurst(oppBox.x + oppBox.w/2, oppBox.y + oppBox.h/2, "#fff", 12, player.facing);
                    createDamageNumber(dmg, oppBox.x + oppBox.w/2, oppBox.y, "#ffcccc");
                }

                setTimeout(() => player.isAttacking = false, 200);
            }

            function receiveDamage(amount, dir, force) {
                if (player.invincible) return;

                let finalDmg = amount;
                
                // Block Check
                if (player.isBlocking) {
                    finalDmg *= 0.2; 
                    createDamageNumber("BLOCKED", player.x, player.y - 20, "#aaa");
                } else {
                    createDamageNumber("-" + Math.round(finalDmg), player.x, player.y - 20, "#f00");
                    screenShake = 12;
                    screenShakeIntensity = 8;
                    directionalBurst(player.x + player.w/2, player.y + player.h/2, player.color, 12, -dir);
                }

                player.hp -= finalDmg;
                player.vx = dir * force; // Knockback applied locally
                
                // Send new HP back to sync UI
                sendData({ type: 'hp_update', hp: player.hp });

                checkDeath();
            }

            function checkCollision(r1, r2) {
                return (r1.x < r2.x + r2.w &&
                        r1.x + r1.w > r2.x &&
                        r1.y < r2.y + r2.h &&
                        r1.y + r1.h > r2.y);
            }

            function checkDeath() {
                if (player.hp <= 0) {
                    player.hp = 0;
                    gameActive = false;
                    // Local Loss
                    showWinScreen(false);
                }
            }

            // ================= VFX & COMBAT HELPERS (ADDED FROM uploaded file) =================

            // spawnParticle: small rectangle particles (keeps compatibility with both versions)
            function spawnParticle(x, y, color = "#fff", count = 6) {
                for (let i = 0; i < (count || 6); i++) {
                    particles.push({
                        x: x + Math.random()*6 - 3,
                        y: y + Math.random()*6 - 3,
                        vx: (Math.random() - 0.5) * 8,
                        vy: (Math.random() - 0.5) * 8,
                        life: 24 + Math.random() * 16,
                        c: color,
                        s: Math.random() * 4 + 2
                    });
                }
            }

            // createDamageNumber - floating damage text
            function createDamageNumber(amount, x, y, color = "#ffffff") {
                damageNums.push({
                    text: Math.round(amount).toString(),
                    x: x,
                    y: y,
                    vy: -1.5,
                    life: 50,
                    c: color
                });
            }

            // burstParticles: larger bursts
            function burstParticles(x, y, color, count = 20, power = 4) {
                for (let i = 0; i < count; i++) {
                    particles.push({
                        x: x,
                        y: y,
                        s: Math.random() * 5 + 3,
                        vx: (Math.random() * power - power / 2),
                        vy: (Math.random() * power - power / 2),
                        life: 20 + Math.random() * 20,
                        c: color
                    });
                }
            }

            // directionalBurst: biased directional particles
            function directionalBurst(x, y, color, count, directionX, spread = 0.5) {
                for (let i = 0; i < count; i++) {
                    particles.push({
                        x: x,
                        y: y,
                        s: Math.random() * 4 + 2,
                        vx: (directionX * (Math.random() * 8 + 4)) + (Math.random() * 2 - 1),
                        vy: (Math.random() * -8) + 4,
                        life: 15 + Math.random() * 20,
                        c: color
                    });
                }
            }

            function createAfterimage(x, y, w, h, color) {
                afterimages.push({ x, y, w, h, life: 15, color });
            }

            function triggerFullFlash(color = "#ffffff", duration = 5) {
                vfxQueue.push({ type: 'fullFlash', life: duration, color: color });
            }

            // updateVFX - process particles, damage text, afterimages and vfxQueue
            function updateVFX() {
                // Particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    const p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.vy += 0.15; // light gravity
                    p.life--;
                    p.s *= 0.98;
                    if (p.life <= 0) particles.splice(i, 1);
                }
                // Damage numbers
                for (let i = damageNums.length - 1; i >= 0; i--) {
                    const d = damageNums[i];
                    d.y += d.vy;
                    d.life--;
                    if (d.life <= 0) damageNums.splice(i, 1);
                }
                // Afterimages
                for (let i = afterimages.length - 1; i >= 0; i--) {
                    afterimages[i].life--;
                    if (afterimages[i].life <= 0) afterimages.splice(i, 1);
                }
                // VFX queue life decay
                for (let i = vfxQueue.length - 1; i >= 0; i--) {
                    vfxQueue[i].life--;
                    if (vfxQueue[i].life <= 0) vfxQueue.splice(i, 1);
                }

                // Combat metrics cleanup (simple)
                if (combatMetrics.comboTimer > 0) {
                    combatMetrics.comboTimer--;
                } else if (combatMetrics.comboCount > 0) {
                    combatMetrics.comboCount = 0;
                }
                const threeSecondsAgo = Date.now() - 3000;
                combatMetrics.damageLog = combatMetrics.damageLog.filter(entry => entry.time > threeSecondsAgo);
                const recentDamage = combatMetrics.damageLog.reduce((sum, entry) => sum + entry.damage, 0);
                combatMetrics.dps = recentDamage / 3.0;
            }

            // ================= VISUALS & DRAWING (enhanced with VFX) =================
            function draw() {
                // screen shake handling
                let sx = 0, sy = 0;
                if (screenShake > 0) {
                    sx = (Math.random() - 0.5) * screenShakeIntensity;
                    sy = (Math.random() - 0.5) * screenShakeIntensity;
                    screenShake--;
                }

                ctx.save();
                ctx.translate(sx, sy);
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Background
                const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
                g.addColorStop(0, '#111');
                g.addColorStop(1, '#222');
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Ground
                ctx.fillStyle = "#333";
                ctx.fillRect(0, GROUND_Y, canvas.width, 100);
                ctx.fillStyle = "#444"; // Grid line
                ctx.fillRect(0, GROUND_Y, canvas.width, 4);

                // Opponent
                if (opponent.connected) {
                    ctx.fillStyle = opponent.isBlocking ? "#555" : opponent.color;
                    if (opponent.isAttacking) ctx.fillStyle = "#fff"; // Flash on attack
                    ctx.fillRect(opponent.x, opponent.y, opponent.w, opponent.h);

                    ctx.fillStyle = "#000";
                    if(opponent.facing === 1) ctx.fillRect(opponent.x + 25, opponent.y + 10, 5, 5);
                    else ctx.fillRect(opponent.x + 10, opponent.y + 10, 5, 5);
                }

                // Afterimages (draw behind player)
                for (let img of afterimages) {
                    ctx.globalAlpha = (img.life / 15) * 0.5;
                    ctx.fillStyle = img.color;
                    ctx.fillRect(img.x, img.y, img.w, img.h);
                }
                ctx.globalAlpha = 1;

                // Player
                ctx.fillStyle = player.isBlocking ? "#888" : player.color;
                if (player.isAttacking) ctx.fillStyle = "#fff";
                ctx.fillRect(player.x, player.y, player.w, player.h);

                ctx.fillStyle = "#000";
                if(player.facing === 1) ctx.fillRect(player.x + 25, player.y + 10, 5, 5);
                else ctx.fillRect(player.x + 10, player.y + 10, 5, 5);

                // Attack hitbox visualization
                if (player.isAttacking) {
                    const range = 50 + (player.stats.str * 1.5);
                    const hitX = player.facing === 1 ? player.x + player.w : player.x - range;
                    ctx.fillStyle = "rgba(255,255,255,0.15)";
                    ctx.fillRect(hitX, player.y, range, player.h);
                }

                // Particles
                for (let p of particles) {
                    ctx.fillStyle = p.c || p.color || "#fff";
                    ctx.fillRect(p.x, p.y, p.s || 3, p.s || 3);
                }

                // Complex VFX
                for (let vfx of vfxQueue) {
                    if (vfx.type === 'shockwave') {
                        const maxLife = 30;
                        const elapsed = maxLife - vfx.life;
                        const progress = Math.max(0, Math.min(1, elapsed / maxLife));
                        const radius = (vfx.maxRadius || 150) * progress;
                        ctx.strokeStyle = vfx.color || "#fff";
                        ctx.lineWidth = 4 * (1 - progress);
                        ctx.beginPath();
                        ctx.arc(vfx.x, vfx.y, radius, 0, Math.PI * 2);
                        ctx.stroke();
                    } else if (vfx.type === 'projectileTrail') {
                        ctx.fillStyle = vfx.color || "#ff6600";
                        const maxLife = 20;
                        const progress = 1 - (vfx.life / maxLife);
                        const currentX = vfx.x + (vfx.targetX - vfx.x) * progress;
                        const currentY = vfx.y + (vfx.targetY - vfx.y) * progress;
                        ctx.beginPath();
                        ctx.arc(currentX, currentY, 10, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (vfx.type === 'impactFlash') {
                         ctx.fillStyle = vfx.color || "#ffaa00";
                         const size = 60 * (1 - vfx.life / 10);
                         ctx.beginPath();
                         ctx.arc(vfx.x, vfx.y, size, 0, Math.PI * 2);
                         ctx.fill();
                    } else if (vfx.type === 'impactRing') {
                         ctx.strokeStyle = vfx.color || "#fff";
                         ctx.lineWidth = 3;
                         const size = (vfx.size || 8) + (50 * (1 - vfx.life / 10));
                         ctx.beginPath();
                         ctx.arc(vfx.x, vfx.y, size, 0, Math.PI * 2);
                         ctx.stroke();
                    } else if (vfx.type === 'fullFlash') {
                        ctx.save();
                        ctx.globalAlpha = Math.min(1, vfx.life / 5);
                        ctx.fillStyle = vfx.color || "#fff";
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.restore();
                    }
                }

                // Damage numbers
                ctx.font = "bold 20px Arial";
                ctx.textAlign = "center";
                for (let t of damageNums) {
                    ctx.fillStyle = "#000";
                    ctx.fillText(t.text, t.x + 2, t.y + 2);
                    ctx.fillStyle = t.c || "#fff";
                    ctx.fillText(t.text, t.x, t.y);
                }

                ctx.restore(); // restore after shake translation
            }

            // ================= misc UI helpers =================
            function spawnFloatText(text, x, y, color) {
                createDamageNumber(text, x, y, color || "#fff");
            }

            function showNotif(msg) {
                const el = document.getElementById('notifArea');
                el.innerText = msg;
                el.style.opacity = 1;
                setTimeout(() => el.style.opacity = 0, 3000);
            }

            function showWinScreen(isWin) {
                const overlay = document.getElementById('winOverlay');
                const title = document.getElementById('winTitle');
                const sub = document.getElementById('winSub');
                
                overlay.style.display = 'block';
                if (isWin) {
                    title.innerText = "VICTORY";
                    title.style.color = "#0f0";
                    sub.innerText = "You defeated the opponent!";
                } else {
                    title.innerText = "DEFEAT";
                    title.style.color = "#f00";
                    sub.innerText = "You were Fractured.";
                }
            }

            // ================= LOOP START =================
            initNetwork();
            
            // Use fixed-step update for logic, render at requestAnimationFrame
            setInterval(update, 1000 / 60); // 60 FPS Logic
            (function renderLoop(){
                draw();
                requestAnimationFrame(renderLoop);
            })();

        </script>
    </body>
</html>
