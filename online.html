<!DOCTYPE html>
<html>
    <head>
        <title>Fracture - PvP Arena</title>
        <script src="https://unpkg.com/peerjs@1.5.1/dist/peerjs.min.js"></script>
        <style>
            body {
                margin: 0;
                overflow: hidden;
                background: #111;
                font-family: 'Courier New', Courier, monospace;
            }

            canvas {
                display: block;
            }

            /* UI LAYOUT */
            #uiLayer {
                position: fixed;
                inset: 0;
                pointer-events: none;
                display: flex;
                flex-direction: column;
                justify-content: space-between;
                padding: 20px;
            }

            /* TOP BAR: HEALTH BARS */
            .top-bar {
                display: flex;
                justify-content: space-between;
                align-items: flex-start;
                width: 100%;
            }

            .player-card {
                width: 40%;
                max-width: 400px;
                background: rgba(0, 0, 0, 0.6);
                border: 1px solid #444;
                padding: 5px;
                border-radius: 4px;
                position: relative;
            }

            .hp-bar-bg {
                width: 100%;
                height: 20px;
                background: #333;
                border: 1px solid #000;
                margin-top: 5px;
            }

            .hp-bar-fill {
                height: 100%;
                background: #0f0;
                width: 100%;
                transition: width 0.1s linear, background 0.2s;
            }
            
            .energy-bar-bg {
                width: 100%;
                height: 6px;
                background: #222;
                margin-top: 2px;
            }
            .energy-bar-fill {
                height: 100%;
                background: #0ff;
                width: 100%;
                transition: width 0.1s linear;
            }

            .name-tag {
                color: #fff;
                font-weight: bold;
                font-size: 14px;
                display: flex;
                justify-content: space-between;
            }

            /* P1 (Left) specific */
            #p1Card .hp-bar-fill { background: #00ffaa; }
            /* P2 (Right) specific */
            #p2Card .hp-bar-fill { background: #ff3333; }
            #p2Card { text-align: right; }

            /* CONNECTION OVERLAY */
            #connectionOverlay {
                position: fixed;
                inset: 0;
                background: #050505;
                z-index: 100;
                display: flex;
                flex-direction: column;
                align-items: center;
                justify-content: center;
                color: #0ff;
            }
            .loader {
                width: 40px;
                height: 40px;
                border: 4px solid #0ff;
                border-top: 4px solid transparent;
                border-radius: 50%;
                animation: spin 1s linear infinite;
                margin-bottom: 20px;
            }
            @keyframes spin { 100% { transform: rotate(360deg); } }
            
            /* WINNER OVERLAY */
            #winOverlay {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: rgba(0,0,0,0.9);
                border: 2px solid #fff;
                padding: 40px;
                text-align: center;
                color: #fff;
                z-index: 50;
                display: none;
            }
            #winTitle { font-size: 40px; font-weight: bold; margin-bottom: 10px; color: #ff0; }
            #winSub { font-size: 14px; color: #aaa; }
            button.retry-btn {
                margin-top: 20px;
                padding: 10px 20px;
                background: #0ff;
                border: none;
                font-weight: bold;
                cursor: pointer;
                pointer-events: auto;
            }

            /* ABILITY BAR */
            #abilityBar {
                align-self: center;
                display: flex;
                gap: 5px;
                background: rgba(0,0,0,0.5);
                padding: 5px;
                border-radius: 5px;
                border: 1px solid #333;
            }
            .slot {
                width: 40px;
                height: 40px;
                background: #222;
                border: 1px solid #555;
                position: relative;
                display: grid;
                place-items: center;
                color: #fff;
                font-size: 10px;
            }
            .cd-overlay {
                position: absolute;
                inset: 0;
                background: rgba(0,0,0,0.7);
                clip-path: inset(0 0 0 0);
            }
            
            /* NOTIFICATIONS */
            #notifArea {
                position: fixed;
                top: 80px;
                left: 50%;
                transform: translateX(-50%);
                text-align: center;
                color: #fff;
                font-size: 14px;
                text-shadow: 0 2px 4px #000;
                z-index: 20;
            }

        </style>
    </head>
    <body>
        <canvas id="gameCanvas"></canvas>
        
        <div id="uiLayer">
            <div class="top-bar">
                <div class="player-card" id="p1Card">
                    <div class="name-tag">
                        <span>YOU</span>
                        <span id="p1HpText">100/100</span>
                    </div>
                    <div class="hp-bar-bg"><div class="hp-bar-fill" id="p1HpFill"></div></div>
                    <div class="energy-bar-bg"><div class="energy-bar-fill" id="p1EngFill"></div></div>
                </div>

                <div class="player-card" id="p2Card">
                    <div class="name-tag">
                        <span id="p2HpText">100/100</span>
                        <span>OPPONENT</span>
                    </div>
                    <div class="hp-bar-bg"><div class="hp-bar-fill" id="p2HpFill"></div></div>
                </div>
            </div>

            <div id="abilityBar">
                <div class="slot">Q<div class="cd-overlay" id="cdQ"></div></div>
                <div class="slot">1<div class="cd-overlay" id="cd1"></div></div>
                <div class="slot">2<div class="cd-overlay" id="cd2"></div></div>
                <div class="slot">3<div class="cd-overlay" id="cd3"></div></div>
                <div class="slot">F</div>
            </div>
        </div>

        <div id="connectionOverlay">
            <div class="loader"></div>
            <h2 id="connStatus">CONNECTING...</h2>
            <div id="connDetails" style="color:#666; margin-top:10px; font-size:12px;">Initializing PeerJS...</div>
        </div>

        <div id="winOverlay">
            <div id="winTitle">VICTORY</div>
            <div id="winSub">You defeated your opponent!</div>
            <button class="retry-btn" onclick="location.reload()">Return to Lobby</button>
        </div>
        
        <div id="notifArea"></div>

        <script>
            // ================= CONFIG & SETUP =================
            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;

            // URL Params for PeerJS
            const urlParams = new URLSearchParams(window.location.search);
            const mode = urlParams.get('mode'); // 'host', 'join'
            const roomId = urlParams.get('room');
            
            // Game State
            let gameActive = false;
            let isHost = (mode === 'host' || mode === 'quick');
            let peer = null;
            let conn = null;

            // Physics Constants
            const GRAVITY = 0.8;
            const GROUND_Y = canvas.height - 100;

            // ================= PLAYER OBJECTS =================
            // Local Player
            const player = {
                x: 200, y: GROUND_Y - 60, w: 40, h: 60,
                vx: 0, vy: 0,
                hp: 100, maxHp: 100, energy: 100,
                facing: 1, // 1 = right, -1 = left
                color: "#00ffaa",
                isBlocking: false,
                isDashing: false,
                isAttacking: false,
                invincible: false,
                attackCooldown: 0,
                stats: { str: 10, spd: 5, def: 0 },
                build: localStorage.getItem('fracture_charbuild') || 'Strength'
            };

            // Remote Player (Opponent)
            const opponent = {
                x: 800, y: GROUND_Y - 60, w: 40, h: 60,
                hp: 100, maxHp: 100,
                facing: -1,
                color: "#ff3333",
                isBlocking: false,
                isAttacking: false, // Visual only
                connected: false
            };

            // Build Stats Configuration
            const builds = {
                'Strength': { str: 15, spd: 4, hp: 120, color: '#ff8800' },
                'Speed':    { str: 8, spd: 9, hp: 90, color: '#00ffff' },
                'Defense':  { str: 10, spd: 3, hp: 150, color: '#4444ff' },
                'Energy':   { str: 12, spd: 5, hp: 100, color: '#aa00ff' }
            };
            
            // Apply Build
            if(builds[player.build]) {
                const b = builds[player.build];
                player.stats.str = b.str;
                player.stats.spd = b.spd;
                player.maxHp = b.hp;
                player.hp = b.hp;
                player.color = b.color;
            }
            opponent.hp = 100; // Will sync later

            // Inputs
            const keys = {};
            document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
            document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
            let mouseDown = false;
            document.addEventListener('mousedown', () => mouseDown = true);
            document.addEventListener('mouseup', () => mouseDown = false);

            // VFX Arrays
            const particles = [];
            const damageNums = [];
            let screenShake = 0;

            // ================= NETWORKING (PEERJS) =================
            function initNetwork() {
                const statusEl = document.getElementById('connStatus');
                const detailsEl = document.getElementById('connDetails');

                if (!roomId && mode !== 'quick') {
                    statusEl.innerText = "NO ROOM ID";
                    detailsEl.innerText = "Please use the menu to create a match.";
                    return;
                }

                // Create Peer
                if (isHost) {
                    // We are hosting, we use the roomId passed or generate one
                    peer = new Peer(roomId); 
                    detailsEl.innerText = "Hosting Room: " + roomId;
                } else {
                    // We are joining, random ID is fine for us
                    peer = new Peer(); 
                    detailsEl.innerText = "Connecting to Host...";
                }

                peer.on('open', (id) => {
                    if (isHost) {
                        statusEl.innerText = "WAITING FOR OPPONENT...";
                        peer.on('connection', (c) => {
                            handleConnection(c);
                        });
                    } else {
                        // Connect to Host
                        const c = peer.connect(roomId);
                        handleConnection(c);
                    }
                });

                peer.on('error', (err) => {
                    statusEl.innerText = "CONNECTION ERROR";
                    detailsEl.innerText = err.type;
                });
            }

            function handleConnection(c) {
                conn = c;
                
                conn.on('open', () => {
                    document.getElementById('connectionOverlay').style.display = 'none';
                    gameActive = true;
                    opponent.connected = true;
                    
                    // Send initial handshake (My Max HP / Build info)
                    sendData({ type: 'handshake', maxHp: player.maxHp, x: player.x });
                    
                    showNotif("FIGHT STARTED!");
                });

                conn.on('data', (data) => {
                    processData(data);
                });
                
                conn.on('close', () => {
                    showNotif("OPPONENT DISCONNECTED");
                    opponent.connected = false;
                });
            }

            function sendData(payload) {
                if (conn && conn.open) {
                    conn.send(payload);
                }
            }

            function processData(data) {
                if (data.type === 'sync') {
                    // Position Sync
                    // Simple interpolation could go here, for now direct mapping
                    opponent.x = data.x;
                    opponent.y = data.y;
                    opponent.facing = data.f;
                    opponent.isBlocking = data.blk;
                    opponent.isAttacking = data.atk; // Just for visual flashing
                } 
                else if (data.type === 'handshake') {
                    opponent.maxHp = data.maxHp;
                    opponent.hp = data.maxHp;
                    // Adjust spawn positions: Host left, Client right
                    if (isHost) { player.x = 200; opponent.x = canvas.width - 200; }
                    else { player.x = canvas.width - 200; opponent.x = 200; }
                }
                else if (data.type === 'hit') {
                    // We got hit! "Trust the attacker" logic
                    receiveDamage(data.dmg, data.kbDir, data.kbForce);
                }
                else if (data.type === 'hp_update') {
                    // Just UI sync to be safe
                    opponent.hp = data.hp;
                }
            }

            // ================= GAME LOGIC =================
            function update() {
                if (!gameActive) return;

                // 1. Movement
                let speed = player.stats.spd;
                if (keys['shift']) speed *= 1.5; // Sprint
                if (player.isBlocking) speed *= 0.4;

                if (keys['a']) { player.vx = -speed; player.facing = -1; }
                else if (keys['d']) { player.vx = speed; player.facing = 1; }
                else { player.vx *= 0.8; } // Friction

                // Jump
                if (keys[' '] && player.y + player.h >= GROUND_Y) {
                    player.vy = -15;
                    spawnParticle(player.x + 20, player.y + 60, "#fff", 5);
                }

                // Physics
                player.vy += GRAVITY;
                player.x += player.vx;
                player.y += player.vy;

                // Floor Collision
                if (player.y + player.h > GROUND_Y) {
                    player.y = GROUND_Y - player.h;
                    player.vy = 0;
                }
                // Wall Collision
                if (player.x < 0) player.x = 0;
                if (player.x > canvas.width - player.w) player.x = canvas.width - player.w;

                // 2. Combat Actions
                if (player.attackCooldown > 0) player.attackCooldown--;

                // Blocking
                player.isBlocking = keys['f'];

                // Attacking (LMB)
                if (mouseDown && player.attackCooldown <= 0 && !player.isBlocking) {
                    performAttack();
                }

                // 3. Network Sync (Send my state every frame or every other frame)
                sendData({
                    type: 'sync',
                    x: Math.round(player.x),
                    y: Math.round(player.y),
                    f: player.facing,
                    blk: player.isBlocking,
                    atk: player.isAttacking
                });

                // 4. Update VFX
                updateVFX();
            }

            function performAttack() {
                player.isAttacking = true;
                player.attackCooldown = 20;
                
                // Visual Lunge
                player.vx = player.facing * 5; 

                // Hitbox Calculation
                const range = 50 + (player.stats.str * 1.5);
                const hitX = player.facing === 1 ? player.x + player.w : player.x - range;
                const hitbox = { x: hitX, y: player.y, w: range, h: player.h };
                const oppBox = { x: opponent.x, y: opponent.y, w: opponent.w, h: opponent.h };

                // Collision Check
                if (checkCollision(hitbox, oppBox)) {
                    // HIT!
                    const dmg = player.stats.str * 1.5; // Base Damage
                    const kbForce = 10;
                    
                    // Visuals
                    screenShake = 5;
                    spawnParticle(oppBox.x + 20, oppBox.y + 30, "#ff0000", 10);
                    
                    // Network: Tell them they got hit
                    sendData({
                        type: 'hit',
                        dmg: dmg,
                        kbDir: player.facing,
                        kbForce: kbForce
                    });
                }

                setTimeout(() => player.isAttacking = false, 200);
            }

            function receiveDamage(amount, dir, force) {
                if (player.invincible) return;

                let finalDmg = amount;
                
                // Block Check
                if (player.isBlocking) {
                    // Check if facing the damage source
                    const hitFromRight = (dir === -1);
                    const facingRight = (player.facing === 1);
                    // If blocking towards the hit? (Simplified: Just press F to reduce dmg)
                    finalDmg *= 0.2; 
                    spawnFloatText("BLOCKED", player.x, player.y - 20, "#aaa");
                } else {
                    spawnFloatText("-" + Math.round(finalDmg), player.x, player.y - 20, "#f00");
                    screenShake = 10;
                    // Blood particles
                    spawnParticle(player.x + 20, player.y + 30, player.color, 15);
                }

                player.hp -= finalDmg;
                player.vx = dir * force; // Knockback applied locally
                
                // Send new HP back to sync UI
                sendData({ type: 'hp_update', hp: player.hp });

                checkDeath();
            }

            function checkCollision(r1, r2) {
                return (r1.x < r2.x + r2.w &&
                        r1.x + r1.w > r2.x &&
                        r1.y < r2.y + r2.h &&
                        r1.y + r1.h > r2.y);
            }

            function checkDeath() {
                if (player.hp <= 0) {
                    player.hp = 0;
                    gameActive = false;
                    // Local Loss
                    showWinScreen(false);
                    // Opponent Win logic handled by them seeing your HP hit 0 or just UI
                }
            }

            // ================= VISUALS & DRAWING =================
            function updateVFX() {
                // Particles
                for (let i = particles.length - 1; i >= 0; i--) {
                    let p = particles[i];
                    p.x += p.vx;
                    p.y += p.vy;
                    p.life--;
                    if (p.life <= 0) particles.splice(i, 1);
                }
                // Text
                for (let i = damageNums.length - 1; i >= 0; i--) {
                    damageNums[i].y -= 1;
                    damageNums[i].life--;
                    if (damageNums[i].life <= 0) damageNums.splice(i, 1);
                }
                // Shake
                if (screenShake > 0) screenShake--;

                // UI Bars
                const p1Pct = Math.max(0, (player.hp / player.maxHp) * 100);
                document.getElementById('p1HpFill').style.width = p1Pct + "%";
                document.getElementById('p1HpText').innerText = Math.ceil(player.hp);
                
                const p2Pct = Math.max(0, (opponent.hp / opponent.maxHp) * 100);
                document.getElementById('p2HpFill').style.width = p2Pct + "%";
                document.getElementById('p2HpText').innerText = Math.ceil(opponent.hp);
                
                // Check Win via UI sync (backup check)
                if (opponent.hp <= 0 && gameActive) {
                    gameActive = false;
                    showWinScreen(true);
                }
            }

            function draw() {
                // Shake Offset
                const sx = (Math.random() - 0.5) * screenShake;
                const sy = (Math.random() - 0.5) * screenShake;
                
                ctx.save();
                ctx.translate(sx, sy);
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // Background
                const g = ctx.createLinearGradient(0, 0, 0, canvas.height);
                g.addColorStop(0, '#111');
                g.addColorStop(1, '#222');
                ctx.fillStyle = g;
                ctx.fillRect(0, 0, canvas.width, canvas.height);

                // Ground
                ctx.fillStyle = "#333";
                ctx.fillRect(0, GROUND_Y, canvas.width, 100);
                ctx.fillStyle = "#444"; // Grid line
                ctx.fillRect(0, GROUND_Y, canvas.width, 4);

                // Draw Opponent
                if (opponent.connected) {
                    ctx.fillStyle = opponent.isBlocking ? "#555" : "#ff3333";
                    if (opponent.isAttacking) ctx.fillStyle = "#fff"; // Flash on attack
                    
                    // Facing flip
                    // Simple Rect for now
                    ctx.fillRect(opponent.x, opponent.y, opponent.w, opponent.h);
                    
                    // Direction indicator (Eye)
                    ctx.fillStyle = "#000";
                    if(opponent.facing === 1) ctx.fillRect(opponent.x + 25, opponent.y + 10, 5, 5);
                    else ctx.fillRect(opponent.x + 10, opponent.y + 10, 5, 5);
                }

                // Draw Player
                ctx.fillStyle = player.isBlocking ? "#888" : player.color;
                if (player.isAttacking) ctx.fillStyle = "#fff"; // Flash
                ctx.fillRect(player.x, player.y, player.w, player.h);
                
                // Eye
                ctx.fillStyle = "#000";
                if(player.facing === 1) ctx.fillRect(player.x + 25, player.y + 10, 5, 5);
                else ctx.fillRect(player.x + 10, player.y + 10, 5, 5);

                // Particles
                for (let p of particles) {
                    ctx.fillStyle = p.c;
                    ctx.fillRect(p.x, p.y, p.s, p.s);
                }

                // Damage Numbers
                ctx.font = "bold 20px Arial";
                for (let t of damageNums) {
                    ctx.fillStyle = "black";
                    ctx.fillText(t.text, t.x + 2, t.y + 2);
                    ctx.fillStyle = t.c;
                    ctx.fillText(t.text, t.x, t.y);
                }

                ctx.restore();
                requestAnimationFrame(draw);
            }

            function spawnParticle(x, y, color, count) {
                for (let i = 0; i < count; i++) {
                    particles.push({
                        x: x, y: y,
                        vx: (Math.random() - 0.5) * 10,
                        vy: (Math.random() - 0.5) * 10,
                        life: 20 + Math.random() * 10,
                        c: color,
                        s: Math.random() * 4 + 2
                    });
                }
            }

            function spawnFloatText(text, x, y, color) {
                damageNums.push({ text: text, x: x, y: y, c: color, life: 40 });
            }

            function showNotif(msg) {
                const el = document.getElementById('notifArea');
                el.innerText = msg;
                el.style.opacity = 1;
                setTimeout(() => el.style.opacity = 0, 3000);
            }

            function showWinScreen(isWin) {
                const overlay = document.getElementById('winOverlay');
                const title = document.getElementById('winTitle');
                const sub = document.getElementById('winSub');
                
                overlay.style.display = 'block';
                if (isWin) {
                    title.innerText = "VICTORY";
                    title.style.color = "#0f0";
                    sub.innerText = "You defeated the opponent!";
                } else {
                    title.innerText = "DEFEAT";
                    title.style.color = "#f00";
                    sub.innerText = "You were Fractured.";
                }
            }

            // ================= LOOP START =================
            initNetwork();
            
            setInterval(update, 1000 / 60); // 60 FPS Logic
            draw(); // Render Loop

        </script>
    </body>
</html>
