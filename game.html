<!DOCTYPE html>
<html>
    <head>
        <title>Fracture - Game</title>
        <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
        <style>
            body {
                margin: 0;
                overflow: hidden;
                background: #111;
                touch-action: none; /* prevent default gestures interfering with controls */
            }

            canvas {
                display: block;
            }

            /* Main HUD Bar (Health, Energy, XP) */
            #mainHud {
                position: fixed;
                top: 10px;
                left: 10px;
                display: flex;
                flex-direction: column;
                gap: 5px;
                z-index: 10;
            }

            .statBarContainer {
                width: 200px;
                height: 16px;
                background: rgba(0, 0, 0, 0.5);
                border: 1px solid #555;
                position: relative;
                box-shadow: 0 0 4px rgba(0, 0, 0, 0.5);
                border-radius: 2px;
            }

            .statBarInner {
                height: 100%;
                transition: width 0.1s linear;
                position: absolute;
                border-radius: 2px;
            }
            .statBarLabel {
                position: absolute;
                width: 100%;
                text-align: center;
                color: #fff;
                font-size: 10px;
                line-height: 16px;
                font-weight: bold;
                text-shadow: 1px 1px 2px #000;
            }

            #hpBarInner { background: #f33; }
            #energyBarInner { background: #00f; }
            #xpBarInner { background: #0f0; }

            #levelDisplay {
                position: absolute;
                left: 210px;
                top: 0px;
                color: #0ff;
                font-weight: bold;
                font-size: 14px;
                text-shadow: 0 0 5px #0ff;
            }

            /* DPS Meter & Combo Counter Container */
            #combatInfo {
                position: fixed;
                top: 10px;
                right: 10px;
                display: flex;
                flex-direction: column;
                align-items: flex-end;
                z-index: 10;
                color: #fff;
                font-family: Arial;
                text-shadow: 1px 1px 2px #000;
            }

            #dpsMeter {
                font-size: 18px;
                font-weight: bold;
                color: #f00; /* Red for damage */
                text-shadow: 0 0 8px #f008;
                margin-bottom: 5px;
            }

            #comboCounter {
                font-size: 24px;
                font-weight: bold;
                color: #ffaa00; /* Gold/Orange for combo */
                text-shadow: 0 0 10px #ffaa00;
                transition: transform 0.1s ease-out;
            }
            
            /* NPC HP Bar */
            #npcHpBar {
                position: fixed;
                top: 10px;
                right: 10px;
                width: 200px;
                height: 20px;
                background: #222;
                border: 2px solid #f33;
                display: none;
            }

            #npcHpBarInner {
                height: 100%;
                width: 100%;
                background: #f33;
            }

            /* Ability Bar */
            #abilityBar {
                position: fixed;
                bottom: 10px;
                left: 50%;
                transform: translateX(-50%);
                width: 200px;
                background: rgba(40, 40, 40, 0.35);
                border-top: 1px solid #b00;
                border-bottom: 1px solid #b00;
                padding: 4px;
                text-align: center;
                color: white;
                font-family: Arial;
                z-index: 20;
                border-radius: 4px;
            }

            #abilityTitle {
                font-size: 10px;
                letter-spacing: 1px;
                font-weight: bold;
                margin-bottom: 2px;
                opacity: 0.8;
            }

            .abilitySlot {
                display: inline-block;
                width: 40px;
                height: 38px;
                margin: 0 2px;
                background: rgba(20, 20, 20, 0.55);
                border: 1px solid #555;
                padding: 2px;
                border-radius: 4px;
                position: relative;
            }

            .abilityKey {
                font-size: 11px;
                color: #fff;
            }

            .abilityName {
                font-size: 8px;
                margin-top: 1px;
                color: #ccc;
            }

            .cooldownOverlay {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0, 0, 0, 0.45);
                pointer-events: none;
                clip-path: inset(0 0 0 0);
                border-radius: 4px;
            }
            
            /* Stats Menu Overlay */
            #statsMenu {
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                width: 300px;
                background: rgba(20, 30, 40, 0.95);
                border: 2px solid #0ff;
                color: white;
                padding: 20px;
                font-family: Arial;
                display: none; /* Hidden by default */
                z-index: 50;
                box-shadow: 0 0 20px #0ff8;
            }
            #statsMenu h2 {
                color: #0ff;
                margin-top: 0;
            }
            .statLine {
                display: flex;
                justify-content: space-between;
                padding: 5px 0;
                border-bottom: 1px dashed #333;
            }
            .statButton {
                background: #0ff;
                color: #111;
                border: none;
                padding: 2px 8px;
                cursor: pointer;
                font-weight: bold;
                border-radius: 2px;
            }
            #statPoints {
                color: #f0f;
                font-weight: bold;
            }

            /* Low HP Overlay */
            #lowHpOverlay {
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background-color: rgba(255, 0, 0, 0.0); /* Start transparent */
                pointer-events: none;
                z-index: 5; /* Below HUD, above canvas */
                transition: background-color 0.1s ease-out; /* Smoother flash transition */
            }

            /* Zero-Point diamond HUD (we draw on canvas but keep a helper div for accessibility if needed) */
            #zeroPointHint {
                position: fixed;
                left: 50%;
                top: 48%;
                transform: translate(-50%, -50%);
                color: #fff;
                font-family: Arial;
                font-size: 12px;
                z-index: 60;
                pointer-events: none;
                text-align: center;
                display: none;
                text-shadow: 0 0 6px #000;
            }

            /* ---------------- Mobile Controls ---------------- */
            #mobileControls {
                position: fixed;
                left: 0;
                right: 0;
                bottom: 0;
                top: 0;
                pointer-events: none; /* container doesn't block canvas but child elements will */
                z-index: 80;
            }

            /* Joystick (left) */
            .joystick {
                position: fixed;
                left: 20px;
                bottom: 120px;
                width: 140px;
                height: 140px;
                border-radius: 50%;
                background: rgba(20,20,20,0.35);
                border: 2px solid rgba(255,255,255,0.06);
                display: flex;
                align-items: center;
                justify-content: center;
                pointer-events: auto;
                touch-action: none;
            }
            .joystick-base {
                position: absolute;
                width: 120px;
                height: 120px;
                border-radius: 50%;
                background: rgba(0,0,0,0.25);
            }
            .joystick-knob {
                position: absolute;
                width: 56px;
                height: 56px;
                border-radius: 50%;
                background: linear-gradient(#fff,#ccc);
                transform: translate(0,0);
                box-shadow: 0 6px 14px rgba(0,0,0,0.5);
            }

            /* Right-side buttons */
            .mobile-buttons {
                position: fixed;
                right: 20px;
                bottom: 40px;
                display: flex;
                flex-direction: column;
                gap: 12px;
                pointer-events: auto;
                align-items: center;
            }

            .mobile-btn {
                width: 76px;
                height: 76px;
                border-radius: 50%;
                background: linear-gradient(#ff7a00,#cc4f00);
                display: flex;
                align-items: center;
                justify-content: center;
                color: white;
                font-weight: bold;
                font-size: 16px;
                box-shadow: 0 6px 18px rgba(0,0,0,0.5);
                user-select: none;
                -webkit-user-select: none;
                touch-action: none;
            }
            .mobile-btn.small {
                width: 56px;
                height: 56px;
                font-size: 13px;
            }
            .mobile-btn.ability {
                background: linear-gradient(#333,#111);
            }
            .mobile-btn.dash { background: linear-gradient(#4aff00,#1f7a00); }
            .mobile-btn.block { background: linear-gradient(#999,#666); }
            .mobile-btn:active, .mobile-btn.active {
                transform: scale(0.96);
                box-shadow: 0 3px 10px rgba(0,0,0,0.6);
            }

            /* show mobile controls only on small screens (phone / tablet) */
            @media (min-width: 900px) {
                #mobileControls { display: none; }
            }
        </style>
    </head>
    <body>
        <canvas id="gameCanvas"></canvas>
        <div id="lowHpOverlay"></div>
        <div id="zeroPointHint">Press R to unleash Zero-Point Impact</div>

        <!-- Mobile Controls -->
        <div id="mobileControls" aria-hidden="false">
            <div class="joystick" id="joystick" role="application" aria-label="Movement joystick">
                <div class="joystick-base"></div>
                <div class="joystick-knob" id="joystickKnob"></div>
            </div>

            <div class="mobile-buttons" id="mobileButtons">
                <div class="mobile-btn ability small" id="btnAbility3" title="Ability 3">3</div>
                <div class="mobile-btn ability small" id="btnAbility2" title="Ability 2">2</div>
                <div class="mobile-btn ability small" id="btnAbility1" title="Ability 1">1</div>
                <div class="mobile-btn dash small" id="btnDash" title="Dash">Q</div>
                <div class="mobile-btn block small" id="btnBlock" title="Block">F</div>
                <div style="height:8px;"></div>
                <div class="mobile-btn" id="btnAttack" title="Attack">ATT</div>
            </div>
        </div>

        <div id="mainHud">
            <div id="levelDisplay">Lvl: 1</div>
            <div class="statBarContainer">
                <div class="statBarInner" id="hpBarInner"></div>
                <div class="statBarLabel" id="hpLabel">HP: 100 / 100</div>
            </div>
            <div class="statBarContainer">
                <div class="statBarInner" id="energyBarInner"></div>
                <div class="statBarLabel" id="energyLabel">Energy: 100 / 100</div>
            </div>
            <div class="statBarContainer">
                <div class="statBarInner" id="xpBarInner"></div>
                <div class="statBarLabel" id="xpLabel">XP: 0 / 100 (Level 1)</div>
            </div>
        </div>

        <div id="combatInfo">
            <div id="dpsMeter">DPS: 0.0</div>
            <div id="comboCounter"></div>
        </div>
        
        <div id="npcHpBar">
            <div id="npcHpBarInner"></div>
        </div>

        <div id="abilityBar">
            <div id="abilityTitle">Universal: <span id="uniAbilityName">Punch</span> (LMB) </div>
            <div class="abilitySlot" id="slot1">
                <div class="cooldownOverlay" id="cool1"></div>
                <div class="abilityKey">1</div>
                <div class="abilityName" id="name1">Ability 1</div>
            </div>
            <div class="abilitySlot" id="slot2">
                <div class="cooldownOverlay" id="cool2"></div>
                <div class="abilityKey">2</div>
                <div class="abilityName" id="name2">Ability 2</div>
            </div>
            <div class="abilitySlot" id="slot3">
                <div class="cooldownOverlay" id="cool3"></div>
                <div class="abilityKey">3</div>
                <div class="abilityName" id="name3">Ability 3</div>
            </div>
            <div class="abilitySlot" id="slot4">
                <div class="cooldownOverlay" id="cool4"></div>
                <div class="abilityKey">4</div>
                <div class="abilityName" id="name4">Punch</div> 
            </div>
        </div>
        
        <div id="statsMenu">
            <h2>Character Progression</h2>
            <p>Unspent Stat Points: <span id="statPoints">0</span></p>
            <div class="statLine">
                <span>Strength: <span id="menuStr">10</span></span>
                <button class="statButton" onclick="distributeStat('strength')">+</button>
            </div>
            <div class="statLine">
                <span>Speed: <span id="menuSpd">4</span></span>
                <button class="statButton" onclick="distributeStat('speed')">+</button>
            </div>
            <div class="statLine">
                <span>Defense: <span id="menuDef">0</span></span>
                <button class="statButton" onclick="distributeStat('defense')">+</button>
            </div>
            <div class="statLine">
                <span>Max HP: <span id="menuHp">100</span></span>
                <button class="statButton" onclick="distributeStat('maxHp')">+</button>
            </div>
            <div class="statLine">
                <span>Energy: <span id="menuEng">100</span></span>
                <button class="statButton" onclick="distributeStat('energy')">+</button>
            </div>
            <p style="margin-top: 15px; color: #aaa;">Press 'C' to Close.</p>
        </div>

        <script>
            // ===== CANVAS & CONTEXT SETUP =====
            const canvas = document.getElementById("gameCanvas");
            const ctx = canvas.getContext("2d");
            canvas.width = innerWidth;
            canvas.height = innerHeight;
            window.addEventListener('resize', () => {
                canvas.width = innerWidth;
                canvas.height = innerHeight;
            });
            
            // ===== PLAYER STATS =====
            const player = {
                x: 0,
                y: 0,
                w: 40,
                h: 60,
                velX: 0,
                velY: 0,
                facing: 1,
                jumpCount: 0,
                maxJumps: 2,
                dashTime: 0,
                dashCooldown: 0,
                attackTime: 0,
                attackCooldown: 0,
                stamina: 100,
                energy: 100,
                hp: 100,
                maxHp: 100,
                level: 1,
                xp: 0,
                xpToNextLevel: 100, 
                unspentStatPoints: 0, 
                invincible: false,
                berserkMode: false,
                isBlocking: false,
                isDashing: false,
                hasDashHit: false,
                stats: {
                    speed: 4,
                    strength: 10,
                    defense: 0,
                    energy: 100,
                    reflectDamage: 0
                },
                // NEW: Variables for tracking ground state and sprinting
                onGround: false,
                wasOnGround: false,
                isSprinting: false,
                justStartedSprinting: false,
                alive: true
            };

            // ===== COMBAT METRICS =====
            const combatMetrics = {
                totalDamage: 0,
                damageLog: [],
                comboCount: 0,
                comboTimer: 0,
                maxCombo: 0,
                dps: 0
            };
            const COMBO_RESET_TIME = 90;

            function getXPForLevel(level) {
                return 100 + (level - 1) * 50; 
            }

            // ===== CHARACTER CREATOR/BUILD SELECTION =====
            const savedBuild = localStorage.getItem('fracture_charbuild') || 'Strength';
            
            const buildStats = {
                'Strength': { str: 18, spd: 3, def: 0, maxHp: 100, abilityNames: ["Ground Smash", "Punch Combo", "Berserk Mode", "Punch"] },
                'Speed': { str: 7, spd: 8, def: 0, maxHp: 100, abilityNames: ["Dash Burst", "Double Jump", "Blur (Invinc)", "Punch"] },
                'Defense': { str: 10, spd: 4, def: 5, maxHp: 140, reflectDamage: 0.3, abilityNames: ["Shield Wall", "Armor Boost", "Thorns (Reflect)", "Punch"] },
                'Energy': { str: 10, spd: 4, def: 0, maxHp: 100, energy: 150, abilityNames: ["Fireball", "Energy Beam", "Teleport", "Punch"] }
            };

            const b = buildStats[savedBuild];
            player.stats.strength = b.str;
            player.stats.speed = b.spd;
            player.stats.defense = b.def;
            player.maxHp = b.maxHp;
            player.hp = b.maxHp;
            player.stats.reflectDamage = b.reflectDamage || 0;
            player.stats.energy = b.energy || 100;
            player.energy = player.stats.energy;
            player.xpToNextLevel = getXPForLevel(player.level);

            document.getElementById("name1").innerText = b.abilityNames[0];
            document.getElementById("name2").innerText = b.abilityNames[1];
            document.getElementById("name3").innerText = b.abilityNames[2];
            document.getElementById("name4").innerText = "Dash/Punch";
            document.getElementById("abilityTitle").innerHTML = `${savedBuild} Build Active / **DASH (Q)** / **BLOCK (F)**`;

            // ===== NPC ===== 
            const npc = {
                x: 400,
                y: 0,
                w: 40,
                h: 60,
                hp: 300,
                maxHp: 300,
                alive: true,
                xpValue: 50,
                isAirborne: false,
                airborneVelY: 0,
                airborneLife: 0,
                // NEW: Physics & Visuals
                velX: 0,
                hitFlashTimer: 0
            };
            const GROUND_Y = canvas.height - 80;

            // ===== INPUT =====
            const keys = {};
            document.addEventListener("keydown", e => keys[e.key.toLowerCase()] = true);
            document.addEventListener("keyup", e => keys[e.key.toLowerCase()] = false);
            let mouseDown = false;
            canvas.addEventListener("mousedown", (e) => {
                if (e.button === 0) mouseDown = true;
            });
            canvas.addEventListener("mouseup", (e) => {
                if (e.button === 0) mouseDown = false;
            });

            // Mobile touch: we will emulate 'a' and 'd' via joystick; other buttons call functions directly

            let menuOpen = false;
            document.addEventListener("keydown", (e) => {
                if (e.key.toLowerCase() === "c") {
                    menuOpen = !menuOpen;
                    document.getElementById('statsMenu').style.display = menuOpen ? 'block' : 'none';
                    if (menuOpen) updateStatsMenu(); 
                }
                if (e.key.toLowerCase() === 'q') {
                    dashMove(); 
                }
                if (e.key.toLowerCase() === 'f' && player.stamina > 0) {
                    player.isBlocking = true;
                }
            });
            document.addEventListener("keyup", (e) => {
                 if (e.key.toLowerCase() === 'f') {
                    player.isBlocking = false;
                 }
            });

            // ===== VFX ARRAYS =====
            const damageNumbers = [];
            const particles = [];
            const afterimages = []; 
            const vfxQueue = []; 
            let camX = 0;
            let abilityCooldowns = [0, 0, 0, 0];
            let screenShakeTime = 0;
            let shakeIntensity = 0;

            // ZERO-POINT IMPACT State
            const zeroPoint = {
                active: false,         // diamond visible and charging
                timer: 0,              // frames since started
                duration: 120,         // frames to full charge (approx 2s at 60fps)
                charged: false,        // fully charged and waiting to be used via punch
                cooldown: 0,           // frames until zero point can be started again
                cooldownMax: 300       // a short cooldown after use
            };

            // INCREASED INTENSITY FOR HEAVIER SHAKE
            function triggerScreenShake(duration = 8, intensity = 6) { 
                screenShakeTime = duration;
                shakeIntensity = intensity;
            }

            // ===== XP & LEVEL UP =====
            function gainXP(amount) {
                if (!player.alive) return;
                player.xp += amount;
                createDamageNumber(amount + " XP", player.x + player.w / 2, player.y - 20, "#00ff00");
                
                while (player.xp >= player.xpToNextLevel) {
                    levelUp();
                }
            }

            function levelUp() {
                player.xp -= player.xpToNextLevel;
                player.level++;
                player.xpToNextLevel = getXPForLevel(player.level);
                player.unspentStatPoints += 3;

                player.hp = player.maxHp;
                player.energy = player.stats.energy;

                triggerScreenShake(30, 15); // HEAVY SHAKE FOR LEVEL UP
                burstParticles(player.x + player.w / 2, player.y + player.h / 2, "#f0f", 80, 20); // MORE PARTICLES
                createDamageNumber("LEVEL UP!", player.x + player.w / 2, player.y - 40, "#f0f");
            }

            function distributeStat(stat) {
                if (player.unspentStatPoints <= 0) return;
                player.unspentStatPoints--;

                if (stat === 'maxHp') {
                    player.maxHp += 10;
                    player.hp += 10;
                } else if (stat === 'energy') {
                    player.stats.energy += 5;
                    player.energy += 5;
                } else {
                    player.stats[stat]++;
                }
                updateStatsMenu();
            }

            // ===== VFX HELPERS =====
            function createDamageNumber(amount, x, y, color = "#ffffff") {
                damageNumbers.push({
                    text: Math.ceil(amount).toString(),
                    x: x,
                    y: y,
                    velY: -3,
                    velX: (Math.random() - 0.5) * 0.5,
                    life: 60,
                    color: color
                });
            }

            function spawnParticle(x, y, color) {
                particles.push({
                    x, y,
                    size: Math.random() * 4 + 2,
                    velX: (Math.random() * 4 - 2),
                    velY: (Math.random() * -2),
                    life: 15,
                    color
                });
            }

            // INCREASED PARTICLE COUNT FOR BURST
            function burstParticles(x, y, color, count = 20, power = 4) {
                for (let i = 0; i < count; i++) {
                    particles.push({
                        x, y,
                        size: Math.random() * 5 + 3,
                        velX: (Math.random() * power - power / 2),
                        velY: (Math.random() * power - power / 2),
                        life: 20,
                        color
                    });
                }
            }
            
            // NEW: Dust Particle for movement/landing
            function createDustParticle(x, y, directionX) {
                particles.push({
                    x: x + Math.random() * 10 - 5,
                    y: y,
                    size: Math.random() * 3 + 1,
                    velX: (Math.random() * 2 - 1) + directionX * 1.5,
                    velY: Math.random() * -2,
                    life: 15,
                    color: "#997755" // Brown/Dust color
                });
            }

            // NEW: Directional Burst (Sparks/Blood fly away from hit)
            function directionalBurst(x, y, color, count, directionX, spread = 0.5) {
                for (let i = 0; i < count; i++) {
                    particles.push({
                        x, y,
                        size: Math.random() * 4 + 2,
                        // Velocity biased towards directionX
                        velX: (directionX * (Math.random() * 8 + 4)) + (Math.random() * 2 - 1), // Increased velocity
                        velY: (Math.random() * -8) + 4, // Increased vertical velocity
                        life: 25,
                        color
                    });
                }
            }

            function createAfterimage(x, y, w, h, color) {
                afterimages.push({
                    x, y, w, h,
                    life: 15,
                    color
                });
            }
            
            // NEW: Full-Screen Flash VFX
            function triggerFullFlash(color = "#ffffff", duration = 5) {
                vfxQueue.push({ type: 'fullFlash', life: duration, color: color });
            }

            // NEW: Zero-Point Impact trigger - shared visual & damage routine
            function triggerZeroPointImpactFromMultiplier(multiplier) {
                const base = player.stats.strength * 1.5;
                const finalDamage = base * multiplier;

                const dist = Math.abs((player.x + player.w/2) - (npc.x + npc.w/2));
                const range = 600;
                if (npc.alive && dist < range) {
                    const knockback = 30 * multiplier;
                    dealDamageToNPC(finalDamage, true, knockback);
                }

                vfxQueue.push({ type: 'zeroImpact', life: 18, color: '#000000', intensity: multiplier });
                burstParticles(player.x + player.w / 2, player.y + player.h / 2, "#ffffff", 120 * multiplier, 35 * multiplier);
                burstParticles(player.x + player.w / 2, player.y + player.h / 2, "#ff0000", 90 * multiplier, 28 * multiplier);
                triggerScreenShake(35, 28 * Math.min(multiplier / 2, 2.5));
                setTimeout(() => {
                    triggerFullFlash("#ffffff", 6);
                }, 60);
                zeroPoint.cooldown = zeroPoint.cooldownMax;
            }

            // ===================== COMBAT & ABILITIES (kept original functions) =====================

            function rectCollide(a, b) {
                return a.x < b.x + b.w && a.x + a.w > b.x && a.y < b.y + a.h && a.y + a.h > b.y;
            }

            function getNPCBox() {
                const ground = GROUND_Y;
                return {
                    x: npc.x,
                    y: npc.isAirborne ? npc.y : ground - npc.h, // Fixed hitbox for airborne
                    w: npc.w,
                    h: npc.h
                };
            }

            function getAttackBox(customWidth) {
                const width = customWidth || (20 + player.stats.strength * 1.5);
                return {
                    x: player.x + (player.facing === 1 ? player.w : -width),
                    y: player.y,
                    w: width,
                    h: player.h
                };
            }

            function dealDamageToNPC(amount, isAbility = false, knockbackForce = 0) {
                let npcBox = getNPCBox();
                let hitbox = getAttackBox();
                let finalDmg = amount;

                if (rectCollide(hitbox, npcBox) && npc.alive) {
                    let dmgColor = isAbility ? "#00ffff" : "#ffffff";
                    let isCrit = Math.random() < 0.1;
                    if (isCrit) {
                        finalDmg *= 1.5;
                        dmgColor = "#ff00ff";
                    }
                    if (player.berserkMode) finalDmg *= 1.25;

                    npc.hp -= finalDmg;

                    let knockDir = (player.x + player.w/2 < npc.x + npc.w/2) ? 1 : -1;
                    npc.velX = knockDir * knockbackForce;

                    npc.hitFlashTimer = 6;

                    directionalBurst(npcBox.x + npcBox.w/2, npcBox.y + npcBox.h/2, "#fff", 15, knockDir);
                    directionalBurst(npcBox.x + npcBox.w/2, npcBox.y + npcBox.h/2, "#ff0000", 10, knockDir / 4, 8);
                    
                    vfxQueue.push({ type: 'impactRing', x: npcBox.x + npcBox.w/2, y: npcBox.y + npcBox.h/2, color: "#fff", life: 10, size: 5 });

                    combatMetrics.totalDamage += finalDmg;
                    combatMetrics.damageLog.push({ time: Date.now(), damage: finalDmg });
                    combatMetrics.comboCount++;
                    combatMetrics.comboTimer = COMBO_RESET_TIME;
                    combatMetrics.maxCombo = Math.max(combatMetrics.maxCombo, combatMetrics.comboCount);

                    document.getElementById('comboCounter').style.transform = 'scale(1.2)';
                    setTimeout(() => {
                        document.getElementById('comboCounter').style.transform = 'scale(1.0)';
                    }, 50);

                    if (isAbility) triggerScreenShake(15, 10);
                    else triggerScreenShake(8, 4);

                    createDamageNumber(finalDmg, npcBox.x + npcBox.w / 2, npcBox.y, dmgColor);
                    document.getElementById("npcHpBar").style.display = "block";
                    
                    if (npc.hp <= 0 && npc.alive) {
                        npc.alive = false;
                        gainXP(npc.xpValue);
                        combatMetrics.comboCount = 0;
                        
                        burstParticles(npc.x + npc.w / 2, npc.y + npc.h / 2, "#f00", 80, 15);
                        triggerScreenShake(20, 15);
                        triggerFullFlash("#ffffff", 5);
                    }
                }
            }
            
            function dealDamageToPlayer(amount) {
                if (player.invincible) return;

                let incomingDmg = amount;
                
                let npcDir = (player.x + player.w/2 < npc.x + npc.w/2) ? 1 : -1; 
                
                if (player.isBlocking) {
                    incomingDmg *= 0.1;
                    createDamageNumber("Block!", player.x + player.w / 2, player.y - 10, "#888");
                    directionalBurst(player.x + player.w/2, player.y + player.h/2, "#00ccff", 10, -npcDir);
                } else {
                    triggerScreenShake(10, 5);
                    directionalBurst(player.x + player.w/2, player.y + player.h/2, "#ffaa00", 15, -npcDir);
                }

                incomingDmg = incomingDmg - player.stats.defense;
                if (incomingDmg < 1) incomingDmg = 1;

                if (player.stats.reflectDamage > 0) {
                    let reflectedDmg = incomingDmg * player.stats.reflectDamage;
                    dealDamageToNPC(reflectedDmg, true, 2); 
                    createDamageNumber(reflectedDmg.toFixed(1) + " Reflect", npc.x + npc.w / 2, npc.y - 10, "#00ff00");
                }

                player.hp -= incomingDmg;
                if (player.hp < 0) player.hp = 0;
                
                if (!player.isBlocking) {
                    player.x += -npcDir * 10;
                    player.velX = -npcDir * 5;
                }
            }
            
            setInterval(() => {
                if (npc.alive && !menuOpen) {
                    if (Math.abs(player.x - npc.x) < 100) {
                        dealDamageToPlayer(15);
                    }
                }
                if (!npc.alive) {
                    npc.hp = npc.maxHp;
                    npc.alive = true;
                    document.getElementById("npcHpBar").style.display = "none";
                    npc.x = 400;
                }
            }, 2000);


            // ===================== ABILITIES (UPDATED PUNCH) =====================
            function universalPunch() {
                if (player.attackCooldown <= 0) {
                    player.attackTime = 10;
                    player.attackCooldown = 20;
                    let damage = player.stats.strength * 1.5; 
                    let moveType = 'Punch';
                    
                    const onGround = player.y + player.h >= GROUND_Y;
                    let knockback = 4;
                    
                    if (!onGround) {
                        if (player.velY < 0) {
                            damage *= 1.8;
                            moveType = 'Uppercut';
                            knockback = 1;
                        } else if (player.velY > 0) {
                            damage *= 2.2;
                            moveType = 'Downslam';
                            knockback = 0;
                        }
                    }

                    if (zeroPoint.charged) {
                        const mul = 2.5 + Math.random() * 0.5;
                        damage *= mul;
                        knockback *= mul * 6;
                        vfxQueue.push({ type: 'zeroImpact', life: 18, color: '#000000', intensity: mul });
                        burstParticles(player.x + player.w/2, player.y + player.h/2, "#ffffff", 80 * mul, 24 * mul);
                        triggerScreenShake(30, 20 * mul);
                        triggerFullFlash("#ffffff", 6);
                        zeroPoint.charged = false;
                        zeroPoint.active = false;
                        zeroPoint.timer = 0;
                        zeroPoint.cooldown = zeroPoint.cooldownMax;
                    }

                    dealDamageToNPC(damage, false, knockback);
                    
                    let npcBox = getNPCBox();
                    let hitbox = getAttackBox();

                    if (rectCollide(hitbox, npcBox) && npc.alive) {
                        if (moveType === 'Uppercut') {
                            vfxQueue.push({ type: 'shockwave', x: npc.x + npc.w / 2, y: npc.y + npc.h / 2, color: "#ffffff", life: 15, radius: 10, maxRadius: 150 });
                            burstParticles(npc.x + npc.w / 2, npc.y + npc.h / 2, "#fff", 80, 15);
                            triggerScreenShake(15, 8);

                            npc.isAirborne = true;
                            npc.airborneVelY = -25;
                            npc.airborneLife = 30;
                            npc.velX = 0;
                            
                            player.velY = -15; 
                            player.jumpCount = player.maxJumps; 
                        } else if (moveType === 'Downslam') {
                            vfxQueue.push({ type: 'shockwave', x: npc.x + npc.w / 2, y: GROUND_Y, color: "#ff0000", life: 30, radius: 20, maxRadius: 800 });
                            burstParticles(npc.x + npc.w / 2, npc.y + npc.h / 2, "#ff0000", 120, 20);
                            triggerScreenShake(30, 20);

                            npc.isAirborne = false; 
                            npc.airborneLife = 0;
                            npc.y = GROUND_Y - npc.h;
                            npc.velX = 0;
                            
                            vfxQueue.push({ type: 'impactFlash', x: npc.x + npc.w / 2, y: GROUND_Y, color: "#ffaa00", life: 10 });

                            player.velY = 0;
                            player.y = GROUND_Y - player.h;
                            player.jumpCount = 0;
                        }
                    }
                }
            }

            // UNIVERSAL DASH 
            function dashMove() {
                if (abilityCooldowns[3] > 0 || player.stamina < 30 || player.isDashing) return;
                
                player.stamina -= 30;
                abilityCooldowns[3] = 70;
                player.dashTime = 15;
                player.isDashing = true; 
                player.hasDashHit = false;
                player.velX = player.facing * 18;
                burstParticles(player.x, player.y + player.h / 2, "#4aff00", 30, 8);
                
                const interval = setInterval(() => {
                    if (player.isDashing) {
                        createAfterimage(player.x, player.y, player.w, player.h, "#00ff0055");
                    } else {
                        clearInterval(interval);
                    }
                }, 40);
            }

            // Abilities shortcuts (keeps existing logic)
            function speed_ability2() {
                if (abilityCooldowns[1] > 0) return;
                abilityCooldowns[1] = 90;
                player.jumpCount = 0;
                player.velY = -12;
                burstParticles(player.x + 20, player.y + player.h, "#0ff", 10, 3);
            }
            function speed_ability3() {
                if (abilityCooldowns[2] > 0 || player.energy < 20) return;
                player.energy -= 20;
                abilityCooldowns[2] = 180;
                player.invincible = true;
                triggerScreenShake(15, 10);
                burstParticles(player.x + player.w / 2, player.y + player.h / 2, "#00ffff", 50, 15);
                setTimeout(() => { player.invincible = false; }, 1000);
            }
            function strength_ability1() {
                if (abilityCooldowns[0] > 0 || player.energy < 30) return;
                player.energy -= 30;
                abilityCooldowns[0] = 90;
                let dmg = player.stats.strength * 2.5;
                dealDamageToNPC(dmg, true, 20);
                burstParticles(player.x + player.w / 2, GROUND_Y, "#ff0000", 50, 12);
                vfxQueue.push({ type: 'shockwave', x: player.x + player.w / 2, y: GROUND_Y, color: "#ff5500", life: 30, radius: 10, maxRadius: 500 });
                triggerScreenShake(20, 15);
            }
            function strength_ability2() {
                if (abilityCooldowns[1] > 0 || player.stamina < 40) return;
                player.stamina -= 40;
                abilityCooldowns[1] = 60;
                let hits = 4;
                let dmgPerHit = player.stats.strength * 0.7;
                for (let i = 0; i < hits; i++) {
                    setTimeout(() => {
                        dealDamageToNPC(dmgPerHit, true, 3); 
                        createAfterimage(player.x + player.w, player.y, 10, player.h, "#ff880055");
                    }, i * 100);
                }
            }
            function strength_ability3() {
                if (abilityCooldowns[2] > 0 || player.energy < 50) return;
                player.energy -= 50;
                abilityCooldowns[2] = 240;
                player.berserkMode = true;
                player.stats.defense = -5;
                burstParticles(player.x + player.w / 2, player.y + player.h / 2, "#ff5555", 80, 20);
                triggerScreenShake(25, 18);
                setTimeout(() => {
                    player.berserkMode = false;
                    player.stats.defense = buildStats[savedBuild].def;
                    burstParticles(player.x + player.w / 2, player.y + player.h / 2, "#55ff55", 50, 12);
                }, 4000);
            }

            function defense_ability1() {
                if (abilityCooldowns[0] > 0 || player.energy < 15) return;
                player.energy -= 15;
                abilityCooldowns[0] = 120;
                player.stats.defense += 10;
                burstParticles(player.x + player.w / 2, player.y + player.h / 2, "#0000ff", 30, 8);
                setTimeout(() => { player.stats.defense -= 10; }, 2000);
            }
            function defense_ability2() {
                if (abilityCooldowns[1] > 0 || player.energy < 20) return;
                player.energy -= 20;
                abilityCooldowns[1] = 180;
                let heal = player.maxHp * 0.15;
                player.hp = Math.min(player.maxHp, player.hp + heal);
                burstParticles(player.x + player.w / 2, player.y + player.h / 2, "#00ff00", 40, 10);
                createDamageNumber(heal.toFixed(0) + " Heal", player.x + player.w / 2, player.y - 20, "#00ff00");
            }
            function defense_ability3() {
                if (abilityCooldowns[2] > 0 || player.energy < 10) return;
                player.energy -= 10;
                abilityCooldowns[2] = 180;
                player.stats.reflectDamage = 0.5;
                burstParticles(player.x + player.w / 2, player.y + player.h / 2, "#8888ff", 25, 6);
                setTimeout(() => { player.stats.reflectDamage = 0.3; }, 3000);
            }

            function energy_ability1() {
                if (abilityCooldowns[0] > 0 || player.energy < 25) return;
                player.energy -= 25;
                abilityCooldowns[0] = 90;
                let dmg = player.stats.energy * 0.8;
                dealDamageToNPC(dmg, true, 10);
                vfxQueue.push({ type: 'projectileTrail', x: player.x + player.w / 2, y: player.y + player.h / 2, targetX: npc.x, targetY: npc.y, color: "#ff6600", life: 20 });
                burstParticles(npc.x, npc.y + npc.h / 2, "#ff6600", 40, 10);
            }
            function energy_ability2() {
                if (abilityCooldowns[1] > 0 || player.energy < 40) return;
                player.energy -= 40;
                abilityCooldowns[1] = 150;
                let dmg = player.stats.energy * 1.5;
                dealDamageToNPC(dmg, true, 25);
                burstParticles(player.x + player.w / 2, player.y + player.h / 2, "#00ffff", 60, 15);
                triggerScreenShake(20, 12);
            }
            function energy_ability3() {
                if (abilityCooldowns[2] > 0 || player.energy < 15) return;
                player.energy -= 15;
                abilityCooldowns[2] = 60;
                createAfterimage(player.x, player.y, player.w, player.h, "#8800ff99");
                burstParticles(player.x, player.y + player.h / 2, "#8800ff", 25, 6);
                player.x += player.facing * 150;
                createAfterimage(player.x, player.y, player.w, player.h, "#8800ff99");
                burstParticles(player.x, player.y + player.h / 2, "#8800ff", 25, 6);
            }

            // ===================== INPUT HANDLER =====================
            function ability1() {
                if (menuOpen) return;
                if (savedBuild === 'Strength') strength_ability1();
                else if (savedBuild === 'Defense') defense_ability1();
                else if (savedBuild === 'Energy') energy_ability1();
            }

            function ability2() {
                if (menuOpen) return;
                if (savedBuild === 'Speed') speed_ability2();
                else if (savedBuild === 'Strength') strength_ability2();
                else if (savedBuild === 'Defense') defense_ability2();
                else if (savedBuild === 'Energy') energy_ability2();
            }

            function ability3() {
                if (menuOpen) return;
                if (savedBuild === 'Speed') speed_ability3();
                else if (savedBuild === 'Strength') strength_ability3();
                else if (savedBuild === 'Defense') defense_ability3();
                else if (savedBuild === 'Energy') energy_ability3();
            }

            document.addEventListener("keydown", (e) => {
                if (e.key === "1") ability1();
                if (e.key === "2") ability2();
                if (e.key === "3") ability3();
                if (e.key.toLowerCase() === 'r') {
                    if ((zeroPoint.active && !zeroPoint.charged) || zeroPoint.charged) {
                        const progress = Math.min(1, zeroPoint.timer / zeroPoint.duration);
                        const minMul = 2.5;
                        const maxMul = 3.0;
                        const mul = 1 + (minMul - 1) * progress + Math.random() * ((maxMul - minMul) * progress);
                        triggerZeroPointImpactFromMultiplier(mul);
                        zeroPoint.charged = false;
                        zeroPoint.active = false;
                        zeroPoint.timer = 0;
                        document.getElementById('zeroPointHint').style.display = 'none';
                    }
                }
            });

            // Right click to start charging Zero-Point diamond (desktop)
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (zeroPoint.cooldown > 0 || menuOpen) return;
                startZeroPointCharge();
            });

            function startZeroPointCharge() {
                zeroPoint.active = true;
                zeroPoint.timer = 0;
                zeroPoint.charged = false;
                document.getElementById('zeroPointHint').style.display = 'block';
                burstParticles(player.x + player.w/2, player.y + player.h/2, "#ff2244", 30, 10);
            }

            function updateAbilityCooldowns() {
                for (let i = 0; i < abilityCooldowns.length; i++) {
                    if (abilityCooldowns[i] > 0) abilityCooldowns[i]--;
                }
            }
            
            function updateCombatMetrics() {
                if (combatMetrics.comboTimer > 0) {
                    combatMetrics.comboTimer--;
                } else if (combatMetrics.comboCount > 0) {
                    combatMetrics.comboCount = 0;
                }
                const threeSecondsAgo = Date.now() - 3000;
                combatMetrics.damageLog = combatMetrics.damageLog.filter(entry => entry.time > threeSecondsAgo);
                const recentDamage = combatMetrics.damageLog.reduce((sum, entry) => sum + entry.damage, 0);
                combatMetrics.dps = recentDamage / 3.0;
            }

            // ===== MOBILE JOYSTICK LOGIC =====
            (function setupMobileControls() {
                const joystick = document.getElementById('joystick');
                const knob = document.getElementById('joystickKnob');
                const btnAttack = document.getElementById('btnAttack');
                const btnA1 = document.getElementById('btnAbility1');
                const btnA2 = document.getElementById('btnAbility2');
                const btnA3 = document.getElementById('btnAbility3');
                const btnDash = document.getElementById('btnDash');
                const btnBlock = document.getElementById('btnBlock');

                let activeTouchId = null;
                let origin = { x: 0, y: 0 };
                const maxRadius = 48; // max knob displacement radius

                function getCenterRect(el) {
                    const r = el.getBoundingClientRect();
                    return { x: r.left + r.width / 2, y: r.top + r.height / 2 };
                }

                function setKnob(dx, dy) {
                    const dist = Math.sqrt(dx*dx + dy*dy);
                    const angle = Math.atan2(dy, dx);
                    const limitedDist = Math.min(dist, maxRadius);
                    const tx = Math.cos(angle) * limitedDist;
                    const ty = Math.sin(angle) * limitedDist;
                    knob.style.transform = `translate(${tx}px, ${ty}px)`;
                }

                function resetKnob() {
                    knob.style.transform = `translate(0px, 0px)`;
                }

                function handleStart(evt) {
                    evt.preventDefault();
                    for (let t of evt.changedTouches) {
                        // if joystick area touched, claim it
                        const rect = joystick.getBoundingClientRect();
                        if (t.clientX >= rect.left && t.clientX <= rect.right && t.clientY >= rect.top && t.clientY <= rect.bottom) {
                            if (activeTouchId === null) {
                                activeTouchId = t.identifier;
                                const c = getCenterRect(joystick);
                                origin.x = c.x;
                                origin.y = c.y;
                                setKnob(0,0);
                            }
                        }
                    }
                }

                function handleMove(evt) {
                    evt.preventDefault();
                    for (let t of evt.changedTouches) {
                        if (t.identifier === activeTouchId) {
                            const dx = t.clientX - origin.x;
                            const dy = t.clientY - origin.y;
                            setKnob(dx, dy);

                            // normalized horizontal input [-1..1]
                            const normX = Math.max(-1, Math.min(1, dx / maxRadius));
                            // map to keys a/d
                            if (normX < -0.25) {
                                keys['a'] = true;
                                keys['d'] = false;
                                player.facing = -1;
                            } else if (normX > 0.25) {
                                keys['d'] = true;
                                keys['a'] = false;
                                player.facing = 1;
                            } else {
                                keys['a'] = false;
                                keys['d'] = false;
                            }

                            // small threshold for jump when swiping up
                            const normY = Math.max(-1, Math.min(1, dy / maxRadius));
                            if (normY < -0.7) { // swipe up - jump
                                if (player.jumpCount < player.maxJumps) {
                                    player.velY = -12;
                                    burstParticles(player.x + 20, player.y + player.h, "#0ff", 10, 3);
                                    player.jumpCount++;
                                    player.onGround = false;
                                }
                            }
                        }
                    }
                }

                function handleEnd(evt) {
                    evt.preventDefault();
                    for (let t of evt.changedTouches) {
                        if (t.identifier === activeTouchId) {
                            activeTouchId = null;
                            resetKnob();
                            keys['a'] = false;
                            keys['d'] = false;
                        }
                    }
                }

                joystick.addEventListener('touchstart', handleStart, {passive:false});
                joystick.addEventListener('touchmove', handleMove, {passive:false});
                joystick.addEventListener('touchend', handleEnd, {passive:false});
                joystick.addEventListener('touchcancel', handleEnd, {passive:false});

                // Buttons: map touch to game functions
                function bindButton(el, onStart, onEnd) {
                    if (!el) return;
                    el.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        el.classList.add('active');
                        if (onStart) onStart(e);
                    }, {passive:false});
                    el.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        el.classList.remove('active');
                        if (onEnd) onEnd(e);
                    }, {passive:false});
                    el.addEventListener('touchcancel', (e) => {
                        e.preventDefault();
                        el.classList.remove('active');
                        if (onEnd) onEnd(e);
                    }, {passive:false});
                }

                bindButton(btnAttack, () => { universalPunch(); }, null);
                bindButton(btnA1, () => { ability1(); }, null);
                bindButton(btnA2, () => { ability2(); }, null);
                bindButton(btnA3, () => { ability3(); }, null);
                bindButton(btnDash, () => { dashMove(); }, null);

                // block: start blocking while pressing
                bindButton(btnBlock,
                    () => { player.isBlocking = true; },
                    () => { player.isBlocking = false; }
                );

                // Prevent clicks from propagating to canvas and causing issues
                const allBtns = document.querySelectorAll('.mobile-btn');
                allBtns.forEach(b => {
                    b.addEventListener('click', (e) => { e.preventDefault(); });
                });
            })();

            // ===== UPDATE & DRAW LOOPS (unchanged but included) =====
            function update() {
                if (menuOpen) return;

                if (zeroPoint.cooldown > 0) zeroPoint.cooldown--;

                if (zeroPoint.active) {
                    zeroPoint.timer++;
                    if (zeroPoint.timer >= zeroPoint.duration) {
                        zeroPoint.charged = true;
                        document.getElementById('zeroPointHint').innerText = 'Zero-Point Ready! Press LMB to punch (or R to detonate)';
                    } else {
                        document.getElementById('zeroPointHint').innerText = 'Zero-Point Charging...';
                    }

                    const lingerFrames = 180;
                    if (!zeroPoint.charged && zeroPoint.timer > zeroPoint.duration + 30) {
                        zeroPoint.active = false;
                        zeroPoint.timer = 0;
                        document.getElementById('zeroPointHint').style.display = 'none';
                    } else if (zeroPoint.charged && zeroPoint.timer > zeroPoint.duration + lingerFrames) {
                        zeroPoint.active = false;
                        zeroPoint.timer = 0;
                        zeroPoint.charged = false;
                        document.getElementById('zeroPointHint').style.display = 'none';
                    }
                }

                if (npc.alive) {
                    npc.x += npc.velX;
                    npc.velX *= 0.9;
                    if (Math.abs(npc.velX) < 0.5) npc.velX = 0;
                    if (npc.hitFlashTimer > 0) npc.hitFlashTimer--;
                    if (npc.x < -200) npc.x = -200;
                    if (npc.x > canvas.width + 200) npc.x = canvas.width + 200;
                }

                if (npc.isAirborne) {
                    const currentGroundY = canvas.height - 80;
                    npc.airborneVelY += 1.2; 
                    npc.y += npc.airborneVelY;
                    npc.airborneLife--;
                    
                    if (npc.airborneLife <= 0 || npc.y + npc.h >= currentGroundY) {
                         npc.isAirborne = false;
                         npc.y = currentGroundY - npc.h;
                         vfxQueue.push({ type: 'impactFlash', x: npc.x + npc.w / 2, y: currentGroundY, color: "#ffaa00", life: 10 });
                    }
                }

                player.wasOnGround = player.onGround;
                const oldVelY = player.velY;
                player.velY += 1.0;

                if (!player.onGround) player.velX *= 0.98;

                if (keys["a"]) player.facing = -1;
                if (keys["d"]) player.facing = 1;
                
                let moveSpeed = player.stats.speed;
                const isMovingHorizontally = keys["a"] || keys["d"];

                const isSprintingAttempt = keys["shift"] && player.stamina > 0 && isMovingHorizontally && !player.isBlocking;
                const wasSprinting = player.isSprinting;
                player.isSprinting = isSprintingAttempt && player.onGround && !player.isDashing;
                player.justStartedSprinting = player.isSprinting && !wasSprinting;

                if (player.isDashing) {
                } else if (player.isBlocking) {
                    moveSpeed *= 0.3;
                } else if (player.isSprinting) {
                    moveSpeed *= 1.7;
                }
                
                if (player.isBlocking && player.stamina > 0) {
                    player.stamina -= 0.8;
                } else if (player.isSprinting) {
                    player.stamina -= 0.5;
                } else {
                    player.stamina += 0.4;
                }
                player.stamina = Math.max(0, Math.min(100, player.stamina));
                player.energy += 0.5;
                player.energy = Math.min(player.stats.energy, player.energy);


                if (!player.isDashing) { 
                    if (keys["a"]) player.velX = -moveSpeed;
                    else if (keys["d"]) player.velX = moveSpeed;
                    else player.velX *= 0.8;
                } else {
                    player.velX *= 0.95;
                }
                
                if (player.justStartedSprinting) {
                    for(let i = 0; i < 15; i++) {
                        createDustParticle(player.x + player.w / 2, GROUND_Y, -player.facing);
                    }
                }
                
                if (player.isSprinting && Math.random() < 0.4) {
                    createDustParticle(player.x + player.w / 2, GROUND_Y, -player.facing);
                }

                if (keys[" "] && player.jumpCount < player.maxJumps) {
                    player.velY = -12;
                    burstParticles(player.x + 20, player.y + player.h, "#0ff", 10, 3);
                    player.jumpCount++;
                    keys[" "] = false;
                    player.onGround = false;
                }

                player.x += player.velX;
                player.y += player.velY;
                const ground = GROUND_Y;
                
                if (player.y + player.h >= ground) {
                    if (!player.wasOnGround && oldVelY > 5) {
                        for(let i = 0; i < 20; i++) {
                            createDustParticle(player.x + player.w / 2, ground, 0);
                        }
                        triggerScreenShake(3, 2);
                    }

                    player.y = ground - player.h;
                    player.velY = 0;
                    player.jumpCount = 0;
                    player.onGround = true;
                } else {
                    player.onGround = false;
                }
                
                if (player.isDashing && npc.alive && !player.hasDashHit) {
                    let dashHitbox = { x: player.x, y: player.y, w: player.w, h: player.h };
                    let npcBox = getNPCBox();

                    if (rectCollide(dashHitbox, npcBox)) {
                        const dashPunchDamage = player.stats.strength * 2.5;
                        dealDamageToNPC(dashPunchDamage, true, 12);

                        player.velX = 0;
                        player.isDashing = false; 
                        player.dashTime = 0; 
                        player.hasDashHit = true;

                        player.attackTime = 10;
                        triggerScreenShake(15, 8);
                    }
                }
                
                if (player.dashTime > 0) player.dashTime--;
                
                if (player.isDashing && player.dashTime <= 0) {
                    player.isDashing = false;
                    player.velX *= 0.8; 
                }

                if (player.dashCooldown > 0) player.dashCooldown--;

                if (mouseDown) universalPunch();
                if (player.attackTime > 0) player.attackTime--;
                if (player.attackCooldown > 0) player.attackCooldown--;

                for (let i = particles.length - 1; i >= 0; i--) {
                    let p = particles[i];
                    p.x += p.velX;
                    p.y += p.velY;
                    p.life--;
                    p.size *= 0.92;
                    if (p.life <= 0) particles.splice(i, 1);
                }
                for (let i = damageNumbers.length - 1; i >= 0; i--) {
                    let d = damageNumbers[i];
                    d.y += d.velY;
                    d.x += d.velX;
                    d.velY *= 0.96;
                    d.life--;
                    if (d.life <= 0) damageNumbers.splice(i, 1);
                }
                for (let i = afterimages.length - 1; i >= 0; i--) { 
                    afterimages[i].life--;
                    if (afterimages[i].life <= 0) afterimages.splice(i, 1);
                }
                for (let i = vfxQueue.length - 1; i >= 0; i--) {
                    vfxQueue[i].life--;
                    if (vfxQueue[i].life <= 0) vfxQueue.splice(i, 1);
                }

                updateAbilityCooldowns();
                updateCombatMetrics(); 

                if (screenShakeTime > 0) {
                    screenShakeTime--;
                }
                camX += ((player.x - canvas.width / 2) - camX) * 0.08;

                updateMainHUD();
                updateCooldownUI();
                updateCombatUI(); 
            }

            function updateMainHUD() {
                const hpRatio = player.hp / player.maxHp;
                document.getElementById("hpBarInner").style.width = (hpRatio * 100) + "%";
                document.getElementById("hpLabel").innerText = `HP: ${parseInt(player.hp)} / ${player.maxHp}`;
                
                const energyRatio = player.energy / player.stats.energy;
                document.getElementById("energyBarInner").style.width = (energyRatio * 100) + "%";
                document.getElementById("energyLabel").innerText = `Energy: ${parseInt(player.energy)} / ${player.stats.energy}`;

                const xpRatio = player.xp / player.xpToNextLevel;
                document.getElementById("xpBarInner").style.width = (xpRatio * 100) + "%";
                document.getElementById("xpLabel").innerText = `XP: ${parseInt(player.xp)} / ${player.xpToNextLevel}`;
                document.getElementById("levelDisplay").innerText = `Lvl: ${player.level}`;
                
                if (npc.alive) {
                    document.getElementById("npcHpBarInner").style.width = (npc.hp / npc.maxHp * 100) + "%";
                }

                let redTintOpacity = 0;
                if (hpRatio < 0.3) {
                    let baseOpacity = (1 - (hpRatio / 0.3)) * 0.08; 
                    const flashComponent = (Math.sin(Date.now() * 0.008) + 1) / 2;
                    redTintOpacity = baseOpacity + (flashComponent * 0.05); 
                }
                document.getElementById('lowHpOverlay').style.backgroundColor = `rgba(255, 0, 0, ${redTintOpacity.toFixed(3)})`;
            }

            function updateCooldownUI() {
                const maxCooldowns = [90, 90, 180, 70]; 
                for (let i = 0; i < 3; i++) {
                    const cooldown = abilityCooldowns[i];
                    const max = maxCooldowns[i] || 1;
                    let ratio = cooldown / max;
                    if (ratio < 0) ratio = 0;
                    document.getElementById("cool" + (i + 1)).style.clipPath = `inset(${ratio * 100}% 0 0 0)`;
                }
                const dashCooldown = abilityCooldowns[3];
                const dashMax = maxCooldowns[3];
                const dashRatio = dashCooldown / dashMax;
                document.getElementById("cool4").style.clipPath = `inset(${dashRatio * 100}% 0 0 0)`;
            }
            
            function updateStatsMenu() {
                document.getElementById('statPoints').innerText = player.unspentStatPoints;
                document.getElementById('menuStr').innerText = player.stats.strength;
                document.getElementById('menuSpd').innerText = player.stats.speed;
                document.getElementById('menuDef').innerText = player.stats.defense;
                document.getElementById('menuHp').innerText = player.maxHp;
                document.getElementById('menuEng').innerText = player.stats.energy;

                const buttons = document.querySelectorAll('#statsMenu .statButton');
                buttons.forEach(btn => {
                    btn.style.display = player.unspentStatPoints > 0 ? 'inline-block' : 'none';
                });
            }

            function updateCombatUI() {
                document.getElementById('dpsMeter').innerText = `DPS: ${combatMetrics.dps.toFixed(1)}`;
                const comboDisplay = document.getElementById('comboCounter');
                if (combatMetrics.comboCount > 1) {
                    comboDisplay.innerText = `${combatMetrics.comboCount}x COMBO`;
                    comboDisplay.style.opacity = 1;
                } else {
                    comboDisplay.innerText = '';
                    comboDisplay.style.opacity = 0;
                }
            }

            // ===== DRAW LOOP (MODIFIED FOR PARALLAX AND FULL FLASH VFX + DIAMOND UI) =====
            function draw() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                let shakeOffsetX = 0;
                let shakeOffsetY = 0;
                if (screenShakeTime > 0) {
                    shakeOffsetX = (Math.random() - 0.5) * shakeIntensity * 2;
                    shakeOffsetY = (Math.random() - 0.5) * shakeIntensity * 2;
                }

                const GROUND_Y_GLOBAL = canvas.height - 80;

                ctx.save(); 
                ctx.translate(shakeOffsetX, shakeOffsetY);
                
                const FAR_BG_FACTOR = 0.1;
                ctx.fillStyle = "#000033"; 
                let farX = (-camX * FAR_BG_FACTOR) % canvas.width;
                ctx.fillRect(farX - canvas.width, 0, canvas.width, GROUND_Y_GLOBAL);
                ctx.fillRect(farX, 0, canvas.width, GROUND_Y_GLOBAL);

                const MID_BG_FACTOR = 0.3;
                ctx.fillStyle = "#0a0a55";
                let midX = (-camX * MID_BG_FACTOR) % 500; 
                for (let i = -3; i < canvas.width / 500 + 3; i++) {
                    ctx.fillRect(midX + i * 500, GROUND_Y_GLOBAL - 80, 50, 80);
                    ctx.fillRect(midX + i * 500 + 100, GROUND_Y_GLOBAL - 150, 80, 150);
                }
                
                const CLOSE_BG_FACTOR = 0.6;
                ctx.fillStyle = "#151577";
                let closeX = (-camX * CLOSE_BG_FACTOR) % 400; 
                for (let i = -5; i < canvas.width / 400 + 5; i++) {
                    ctx.fillRect(closeX + i * 400, GROUND_Y_GLOBAL - 40, 30, 40);
                }
                
                ctx.restore();

                ctx.save(); 
                ctx.translate(shakeOffsetX, shakeOffsetY);
                ctx.translate(-camX, 0);

                ctx.fillStyle = "#222";
                ctx.fillRect(camX - 1000, GROUND_Y_GLOBAL, canvas.width + 2000, 80);
                
                for (let img of afterimages) {
                    ctx.fillStyle = img.color;
                    ctx.globalAlpha = img.life / 15 * 0.5;
                    ctx.fillRect(img.x, img.y, img.w, img.h);
                }
                ctx.globalAlpha = 1;

                if (npc.alive) {
                    const npcDrawY = npc.isAirborne ? npc.y : GROUND_Y_GLOBAL - npc.h;
                    
                    if (npc.hitFlashTimer > 0) {
                        ctx.fillStyle = "#ffffff";
                        ctx.shadowBlur = 20;
                        ctx.shadowColor = "white";
                    } else {
                        ctx.fillStyle = "#f33";
                        ctx.shadowBlur = 0;
                    }

                    ctx.fillRect(npc.x, npcDrawY, npc.w, npc.h);
                    ctx.shadowBlur = 0;
                    
                    if(npc.isAirborne) {
                        ctx.strokeStyle = "#ffffff";
                        ctx.lineWidth = 1;
                        ctx.globalAlpha = 0.5;
                        ctx.beginPath();
                        ctx.moveTo(npc.x + npc.w/2, npcDrawY);
                        ctx.lineTo(npc.x + npc.w/2, GROUND_Y_GLOBAL - npc.h);
                        ctx.stroke();
                        ctx.globalAlpha = 1;
                    }
                }

                ctx.fillStyle = "#4af";
                if (player.invincible) {
                    ctx.fillStyle = "#00ffff";
                    ctx.globalAlpha = 0.5 + Math.sin(Date.now() / 50) * 0.3;
                } else if (player.berserkMode) {
                    ctx.fillStyle = "#ff5555";
                } else if (player.isBlocking) {
                    ctx.fillStyle = "#aaa";
                } else if (player.isDashing) {
                    ctx.fillStyle = "#4aff00";
                }
                ctx.fillRect(player.x, player.y, player.w, player.h);
                ctx.globalAlpha = 1;

                if (player.isBlocking) {
                    ctx.strokeStyle = "#ffffff";
                    ctx.lineWidth = 3;
                    ctx.globalAlpha = 0.8;
                    ctx.beginPath();
                    if (player.facing === 1) {
                         ctx.arc(player.x + player.w, player.y + player.h / 2, 25, Math.PI / 2, -Math.PI / 2);
                    } else {
                         ctx.arc(player.x, player.y + player.h / 2, 25, -Math.PI / 2, Math.PI / 2);
                    }
                    ctx.stroke();
                    ctx.globalAlpha = 1;
                }

                if (player.attackTime > 0) {
                    let hitbox = getAttackBox();
                    ctx.fillStyle = "rgba(255,255,255,0.3)";
                    ctx.fillRect(hitbox.x, hitbox.y, hitbox.w, hitbox.h);
                }

                for (let p of particles) {
                    ctx.fillStyle = p.color;
                    ctx.fillRect(p.x, p.y, p.size, p.size);
                }

                for (let vfx of vfxQueue) {
                    ctx.globalAlpha = vfx.life / (vfx.life > 20 ? 30 : 10);
                    if (vfx.type === 'shockwave') {
                        const maxLife = 30;
                        const currentRadius = vfx.radius + (vfx.maxRadius - vfx.radius) * (1 - vfx.life / maxLife);
                        ctx.strokeStyle = vfx.color;
                        ctx.lineWidth = 4;
                        ctx.beginPath();
                        ctx.arc(vfx.x, vfx.y, currentRadius, Math.PI, 0); 
                        ctx.stroke();
                    } else if (vfx.type === 'projectileTrail') {
                        ctx.fillStyle = vfx.color;
                        const maxLife = 20;
                        const progress = 1 - vfx.life / maxLife;
                        const currentX = vfx.x + (vfx.targetX - vfx.x) * progress;
                        const currentY = vfx.y + (GROUND_Y_GLOBAL - npc.h / 2 - vfx.y) * progress;
                        ctx.beginPath();
                        ctx.arc(currentX, currentY, 10, 0, Math.PI * 2);
                        ctx.fill();
                    } else if (vfx.type === 'impactFlash') {
                         ctx.fillStyle = vfx.color;
                         const size = 60 * (1 - vfx.life / 10);
                         ctx.beginPath();
                         ctx.arc(vfx.x, vfx.y, size, 0, Math.PI * 2);
                         ctx.fill();
                    } else if (vfx.type === 'impactRing') {
                         ctx.strokeStyle = vfx.color;
                         ctx.lineWidth = 3;
                         const size = vfx.size + (50 * (1 - vfx.life / 10));
                         ctx.beginPath();
                         ctx.arc(vfx.x, vfx.y, size, 0, Math.PI * 2);
                         ctx.stroke();
                    } else if (vfx.type === 'zeroImpact') {
                        const lifePct = vfx.life / 18;
                        ctx.save();
                        ctx.globalAlpha = 0.85 * lifePct;
                        ctx.fillStyle = vfx.color;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.restore();
                        ctx.save();
                        ctx.globalCompositeOperation = 'lighter';
                        const centerAlpha = 1 - lifePct;
                        ctx.globalAlpha = centerAlpha * 0.9;
                        const maxR = Math.max(canvas.width, canvas.height) * 0.6 * (vfx.intensity || 1);
                        ctx.beginPath();
                        ctx.fillStyle = "#ffffff";
                        ctx.arc(canvas.width/2, canvas.height/2, maxR * (1 - lifePct*0.5), 0, Math.PI*2);
                        ctx.fill();
                        ctx.restore();
                    }
                }
                ctx.globalAlpha = 1;

                ctx.font = "bold 18px Arial";
                ctx.textAlign = "center";
                for (let d of damageNumbers) {
                    const alpha = d.life / 60;
                    ctx.fillStyle = d.color;
                    ctx.globalAlpha = alpha;
                    ctx.strokeStyle = "#000000";
                    ctx.lineWidth = 3;
                    ctx.strokeText(d.text, d.x, d.y);
                    ctx.fillText(d.text, d.x, d.y);
                }
                ctx.globalAlpha = 1;

                ctx.restore();
                
                for (let i = vfxQueue.length - 1; i >= 0; i--) {
                    const vfx = vfxQueue[i];
                    if (vfx.type === 'fullFlash') {
                        ctx.save();
                        ctx.globalAlpha = vfx.life / 5;
                        ctx.fillStyle = vfx.color;
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.restore();
                    }
                }

                if (zeroPoint.active || zeroPoint.charged) {
                    const cx = canvas.width / 2;
                    const cy = canvas.height / 2 - 80;
                    const size = 120;
                    const progress = Math.min(1, zeroPoint.timer / zeroPoint.duration);
                    ctx.save();
                    const auraAlpha = zeroPoint.charged ? 0.9 : 0.35 + Math.sin(Date.now() * 0.02) * 0.15;
                    ctx.globalAlpha = auraAlpha;
                    ctx.fillStyle = '#8b0000';
                    ctx.beginPath();
                    ctx.ellipse(cx, cy, size * (1.4 + (zeroPoint.charged ? 0.5 : 0.1)), size * (1.4 + (zeroPoint.charged ? 0.5 : 0.1)), 0, 0, Math.PI*2);
                    ctx.fill();
                    ctx.globalAlpha = 1;

                    ctx.translate(cx, cy);
                    ctx.rotate(Math.PI/4 + (Date.now() * 0.001));
                    ctx.lineWidth = 6;
                    ctx.strokeStyle = zeroPoint.charged ? '#ff4444' : '#ff0000';
                    ctx.strokeRect(-size/2, -size/2, size, size);
                    const innerMax = size - 16;
                    const innerSize = innerMax * progress;
                    ctx.fillStyle = zeroPoint.charged ? '#ffaaaa' : '#550000';
                    ctx.fillRect(-innerSize/2, -innerSize/2, innerSize, innerSize);
                    ctx.lineWidth = 2;
                    ctx.strokeStyle = '#000';
                    ctx.strokeRect(-innerSize/2, -innerSize/2, innerSize, innerSize);

                    ctx.rotate(-Math.PI/4 - (Date.now() * 0.001));
                    ctx.translate(-cx, -cy);

                    ctx.fillStyle = '#000';
                    ctx.globalAlpha = 0.6;
                    ctx.beginPath();
                    ctx.arc(cx, cy, 8, 0, Math.PI*2);
                    ctx.fill();
                    ctx.globalAlpha = 1;

                    ctx.fillStyle = '#fff';
                    ctx.font = 'bold 14px Arial';
                    ctx.textAlign = 'center';
                    if (!zeroPoint.charged) {
                        ctx.fillText('Charging...', cx, cy + size/1.6);
                    } else {
                        ctx.fillText('Zero-Point Ready!', cx, cy + size/1.6);
                    }

                    ctx.restore();
                } else {
                    document.getElementById('zeroPointHint').style.display = 'none';
                }
            }

            function loop() {
                update();
                draw();
                requestAnimationFrame(loop);
            }
            loop();
        </script>
    </body>
</html>
